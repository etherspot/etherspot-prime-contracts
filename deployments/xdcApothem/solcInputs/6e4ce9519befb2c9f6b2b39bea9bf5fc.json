{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "account-abstraction/contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"
    },
    "account-abstraction/contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"
    },
    "account-abstraction/contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "account-abstraction/contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"
    },
    "account-abstraction/contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "account-abstraction/contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "account-abstraction/contracts/interfaces/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"
    },
    "forge-std/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "solady/src/auth/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
    },
    "solady/src/utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n///\n/// @dev Note:\n/// - The recovery functions use the ecrecover precompile (0x1).\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\n///   This is for more safety by default.\n///   Use the `tryRecover` variants if you need to get the zero address back\n///   upon recovery failure instead.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT use signatures as unique identifiers:\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// This implementation does NOT check if a signature is non-malleable.\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            for {} 1 {} {\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        result, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            for {} 1 {} {\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        result, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result :=\n                mload(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        1, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x01, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            for {} 1 {} {\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                if eq(mload(signature), 64) {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(mload(signature), 65) {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    result, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            for {} 1 {} {\n                if eq(signature.length, 64) {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                    break\n                }\n                if eq(signature.length, 65) {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                    break\n                }\n                result := 0\n                break\n            }\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    result, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    1, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    1, // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x40, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"
    },
    "solady/src/utils/LibClone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here implements a `receive()` method that emits the\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\n/// composability. The minimal proxy implementation does not offer this feature.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n///\n/// @dev ERC1967I proxy:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\nlibrary LibClone {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\n    bytes32 internal constant ERC1967_CODE_HASH =\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\n    bytes32 internal constant ERC1967I_CODE_HASH =\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`.\n    function initCode(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(result, 0x28), implementation)\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(result, 0x35) // Store the length.\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(result, 0x26), implementation) // 20\n            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(result, 0x36) // Store the length.\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This implementation of CWIA differs from the original implementation.\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\n        instance = clone(0, implementation, data);\n    }\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation, bytes memory data)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 108`\n            // The `runSize` is `creationSize - 10`.\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\n             * 57       | JUMPI          |                          |                                             |\n             * 34       | CALLVALUE      | cv                       |                                             |\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\n             * 5b       | JUMPDEST       |                          |                                             |\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, data, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory data,\n        bytes32 salt\n    ) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    function initCode(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let dataLength := mload(data)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            let o := add(result, 0x8c)\n            let end := add(o, dataLength)\n\n            // Copy the `data` into `result`.\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(o, 0x20)\n                if iszero(lt(o, end)) { break }\n            }\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                add(result, 0x4b),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                add(result, 0x32),\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                add(result, 0x12),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(end, shl(0xf0, extraLength))\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\n            mstore(0x40, add(0x22, end)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(\n                add(result, 0x60),\n                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300\n            )\n            mstore(\n                add(result, 0x40),\n                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc\n            )\n            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(result, 0x09), 0x603d3d8160223d3973)\n            mstore(result, 0x5f) // Store the length.\n            mstore(0x40, add(result, 0x80)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                 ERC1967I PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.\n    function deployERC1967I(address implementation) internal returns (address instance) {\n        instance = deployERC1967I(0, implementation);\n    }\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             *                                                                                  |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(\n                add(result, 0x74),\n                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3\n            )\n            mstore(\n                add(result, 0x54),\n                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4\n            )\n            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(result, 0x1d), implementation)\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\n            mstore(add(result, 0x94), 0)\n            mstore(result, 0x74) // Store the length.\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\n    function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/access/AccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IAccessController} from \"../interfaces/IAccessController.sol\";\nimport {ErrorsLib} from \"../libraries/ErrorsLib.sol\";\n\ncontract AccessController is IAccessController {\n    /// State Variables\n    uint128 constant MULTIPLY_FACTOR = 1000;\n    uint16 constant SIXTY_PERCENT = 600;\n    uint24 constant INITIAL_PROPOSAL_TIMELOCK = 24 hours;\n    uint256 public ownerCount;\n    uint256 public guardianCount;\n    uint256 public proposalId;\n    uint256 public proposalTimelock;\n\n    /// Mappings\n    mapping(address => bool) private _owners;\n    mapping(address => bool) private _guardians;\n    mapping(uint256 => NewOwnerProposal) private _proposals;\n\n    /// Modifiers\n    modifier onlyOwnerOrSelf() {\n        if (!(isOwner(msg.sender) || msg.sender == address(this))) {\n            revert ErrorsLib.OnlyOwnerOrSelf();\n        }\n        _;\n    }\n\n    modifier onlyGuardian() {\n        if (!isGuardian(msg.sender)) {\n            revert ErrorsLib.OnlyGuardian();\n        }\n        _;\n    }\n\n    modifier onlyOwnerOrGuardianOrSelf() {\n        if (\n            !(isOwner(msg.sender) ||\n                isGuardian(msg.sender) ||\n                msg.sender == address(this))\n        ) {\n            revert ErrorsLib.OnlyOwnerOrGuardianOrSelf();\n        }\n        _;\n    }\n\n    /// External\n    /**\n     * @notice Add owner to the wallet.\n     * @dev Only owner or wallet.\n     * @param _newOwner address of new owner to add.\n     */\n    function addOwner(address _newOwner) external onlyOwnerOrSelf {\n        if (\n            _newOwner == address(0) ||\n            isGuardian(_newOwner) ||\n            isOwner(_newOwner)\n        ) {\n            revert ErrorsLib.AddingInvalidOwner();\n        }\n        _addOwner(_newOwner);\n        emit OwnerAdded(address(this), _newOwner);\n    }\n\n    /**\n     * @notice Remove owner from wallet.\n     * @dev Only owner or wallet.\n     * @param _owner address of wallet owner to remove .\n     */\n    function removeOwner(address _owner) external onlyOwnerOrSelf {\n        if (!isOwner(_owner)) revert ErrorsLib.RemovingInvalidOwner();\n        if (ownerCount <= 1) {\n            revert ErrorsLib.WalletNeedsOwner();\n        }\n        _removeOwner(_owner);\n        emit OwnerRemoved(address(this), _owner);\n    }\n\n    /**\n     * @notice Add guardian for the wallet.\n     * @dev Only owner or wallet.\n     * @param _newGuardian address of new guardian to add to wallet.\n     */\n    function addGuardian(address _newGuardian) external onlyOwnerOrSelf {\n        if (\n            _newGuardian == address(0) ||\n            isGuardian(_newGuardian) ||\n            isOwner(_newGuardian)\n        ) {\n            revert ErrorsLib.AddingInvalidGuardian();\n        }\n        _addGuardian(_newGuardian);\n        emit GuardianAdded(address(this), _newGuardian);\n    }\n\n    /**\n     * @notice Remove guardian from the wallet.\n     * @dev Only owner or wallet.\n     * @param _guardian address of existing guardian to remove.\n     */\n    function removeGuardian(address _guardian) external onlyOwnerOrSelf {\n        if (!isGuardian(_guardian)) revert ErrorsLib.RemovingInvalidGuardian();\n        _removeGuardian(_guardian);\n        emit GuardianRemoved(address(this), _guardian);\n    }\n\n    /**\n     * @notice Change the timelock on proposals.\n     * The minimum time (secs) that a proposal is allowed to be discarded.\n     * @dev Only owner or wallet.\n     * @param   _newTimelock new timelock in seconds.\n     */\n    function changeProposalTimelock(\n        uint256 _newTimelock\n    ) external onlyOwnerOrSelf {\n        assembly {\n            sstore(proposalTimelock.slot, _newTimelock)\n        }\n    }\n\n    /**\n     * @notice Discards the current proposal.\n     * @dev Only owner or guardian or wallet. Must be after the proposal timelock is met.\n     */\n    function discardCurrentProposal() public onlyOwnerOrGuardianOrSelf {\n        NewOwnerProposal storage prop = _proposals[proposalId];\n        uint256 timelock = proposalTimelock == 0\n            ? INITIAL_PROPOSAL_TIMELOCK\n            : proposalTimelock;\n        if (_resolvedProposal()) {\n            revert ErrorsLib.ProposalResolved();\n        }\n        bool allowed = isGuardian(msg.sender);\n        if (allowed && (prop.proposedAt + timelock >= block.timestamp))\n            revert ErrorsLib.ProposalTimelocked();\n\n        prop.resolved = true;\n        emit ProposalDiscarded(address(this), proposalId, msg.sender);\n    }\n\n    /**\n     * @notice Creates a new owner proposal (adds new owner to wallet).\n     * @dev Only guardian.\n     * @param _newOwner the proposed new owner for the wallet.\n     */\n    function guardianPropose(address _newOwner) external onlyGuardian {\n        if (\n            _newOwner == address(0) ||\n            isGuardian(_newOwner) ||\n            isOwner(_newOwner)\n        ) {\n            revert ErrorsLib.AddingInvalidOwner();\n        }\n        if (guardianCount < 3) {\n            revert ErrorsLib.NotEnoughGuardians();\n        }\n        NewOwnerProposal storage prop = _proposals[proposalId];\n        if (prop.guardiansApproved.length != 0 && !prop.resolved) {\n            revert ErrorsLib.ProposalUnresolved();\n        }\n        uint256 newProposalId = proposalId + 1;\n        _proposals[newProposalId].newOwnerProposed = _newOwner;\n        _proposals[newProposalId].guardiansApproved.push(msg.sender);\n        _proposals[newProposalId].approvalCount++;\n        _proposals[newProposalId].resolved = false;\n        _proposals[newProposalId].proposedAt = block.timestamp;\n        proposalId = newProposalId;\n        emit ProposalSubmitted(\n            address(this),\n            newProposalId,\n            _newOwner,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Cosigns a new owner proposal.\n     * @dev Only guardian. Must meet minimum threshold of 60% of total guardians to add new owner.\n     */\n    function guardianCosign() external onlyGuardian {\n        uint256 latestId = proposalId;\n        NewOwnerProposal storage latestProp = _proposals[latestId];\n        if (latestId == 0) {\n            revert ErrorsLib.InvalidProposal();\n        }\n        if (_checkIfSigned(latestId)) {\n            revert ErrorsLib.AlreadySignedProposal();\n        }\n        if (_resolvedProposal()) {\n            revert ErrorsLib.ProposalResolved();\n        }\n        _proposals[latestId].guardiansApproved.push(msg.sender);\n        _proposals[latestId].approvalCount++;\n        address newOwner = latestProp.newOwnerProposed;\n        if (_checkQuorumReached(latestId)) {\n            _proposals[latestId].resolved = true;\n            _addOwner(newOwner);\n        } else {\n            emit QuorumNotReached(\n                address(this),\n                latestId,\n                newOwner,\n                _proposals[latestId].approvalCount\n            );\n        }\n    }\n\n    /// Views\n    /**\n     * @notice Checks if _address is owner of wallet.\n     * @param _address address to check if owner of wallet.\n     * @return  bool.\n     */\n    function isOwner(address _address) public view returns (bool) {\n        return _owners[_address];\n    }\n\n    /**\n     * @notice Checks if _address is guardian of wallet.\n     * @param _address address to check if guardian of wallet.\n     * @return  bool.\n     */\n    function isGuardian(address _address) public view returns (bool) {\n        return _guardians[_address];\n    }\n\n    /**\n     * @notice Returns new owner proposal data.\n     * @param _proposalId proposal id to return data for.\n     * @return ownerProposed_ the new owner proposed.\n     * @return approvalCount_ number of guardians that have approved the proposal.\n     * @return guardiansApproved_ array of guardian addresses that have approved proposal.\n     * @return resolved_ bool is the proposal resolved.\n     * @return proposedAt_ timestamp of when proposal was initiated.\n     */\n    function getProposal(\n        uint256 _proposalId\n    )\n        public\n        view\n        returns (\n            address ownerProposed_,\n            uint256 approvalCount_,\n            address[] memory guardiansApproved_,\n            bool resolved_,\n            uint256 proposedAt_\n        )\n    {\n        if (_proposalId == 0 || _proposalId > proposalId) {\n            revert ErrorsLib.InvalidProposal();\n        }\n        NewOwnerProposal memory proposal = _proposals[_proposalId];\n        return (\n            proposal.newOwnerProposed,\n            proposal.approvalCount,\n            proposal.guardiansApproved,\n            proposal.resolved,\n            proposal.proposedAt\n        );\n    }\n\n    /// Internal\n    function _addOwner(address _newOwner) internal {\n        _owners[_newOwner] = true;\n        ownerCount++;\n    }\n\n    function _addGuardian(address _newGuardian) internal {\n        _guardians[_newGuardian] = true;\n        guardianCount++;\n        if (!_resolvedProposal()) discardCurrentProposal();\n    }\n\n    function _removeOwner(address _owner) internal {\n        _owners[_owner] = false;\n        ownerCount--;\n    }\n\n    function _removeGuardian(address _guardian) internal {\n        _guardians[_guardian] = false;\n        guardianCount--;\n        if (!_resolvedProposal()) discardCurrentProposal();\n    }\n\n    function _checkIfSigned(uint256 _proposalId) internal view returns (bool) {\n        for (\n            uint256 i;\n            i < _proposals[_proposalId].guardiansApproved.length;\n            i++\n        ) {\n            if (_proposals[_proposalId].guardiansApproved[i] == msg.sender) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _checkQuorumReached(\n        uint256 _proposalId\n    ) internal view returns (bool) {\n        return ((_proposals[_proposalId].approvalCount * MULTIPLY_FACTOR) /\n            guardianCount >=\n            SIXTY_PERCENT);\n    }\n\n    function _resolvedProposal() internal view returns (bool) {\n        NewOwnerProposal storage prop = _proposals[proposalId];\n        return prop.resolved;\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/core/AccountBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/**\n * @title reference implementation of the minimal modular smart account with Hook Extension\n * @author zeroknots.eth | rhinestone.wtf\n */\ncontract AccountBase {\n    error AccountAccessUnauthorized();\n    /////////////////////////////////////////////////////\n    // Access Control\n    ////////////////////////////////////////////////////\n\n    modifier onlyEntryPointOrSelf() virtual {\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(\n                    call(\n                        gas(),\n                        caller(),\n                        missingAccountFunds,\n                        codesize(),\n                        0x00,\n                        codesize(),\n                        0x00\n                    )\n                )\n            }\n        }\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/core/ExecutionHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * @title Execution\n * @dev This contract executes calls in the context of this contract.\n * @author zeroknots.eth | rhinestone.wtf\n * shoutout to solady (vectorized, ross) for this code\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\n */\ncontract ExecutionHelper {\n    error ExecutionFailed();\n\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\n\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function _tryExecute(Execution[] calldata executions)\n        internal\n        returns (bytes[] memory result)\n    {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            bool success;\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\n        }\n    }\n\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function _tryExecute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    function _executeDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\n    function _tryExecuteDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            success :=\n                delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n}"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/core/HookManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"./ModuleManager.sol\";\nimport \"../interfaces/IERC7579Account.sol\";\nimport \"../interfaces/IERC7579Module.sol\";\n/**\n * @title reference implementation of HookManager\n * @author zeroknots.eth | rhinestone.wtf\n */\n\nabstract contract HookManager {\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\n    struct HookManagerStorage {\n        IHook _hook;\n    }\n\n    // keccak256(\"hookmanager.storage.msa\");\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\n        0x36e05829dd1b9a4411d96a3549582172d7f071c1c0db5c573fcf94eb28431608;\n\n    error HookPostCheckFailed();\n    error HookAlreadyInstalled(address currentHook);\n\n    modifier withHook() {\n        address hook = _getHook();\n        if (hook == address(0)) {\n            _;\n        } else {\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.data);\n            _;\n            if (!IHook(hook).postCheck(hookData)) revert HookPostCheckFailed();\n        }\n    }\n\n    function _setHook(address hook) internal virtual {\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\n        assembly {\n            sstore(slot, hook)\n        }\n    }\n\n    function _installHook(address hook, bytes calldata data) internal virtual {\n        address currentHook = _getHook();\n        if (currentHook != address(0)) {\n            revert HookAlreadyInstalled(currentHook);\n        }\n        _setHook(hook);\n        IHook(hook).onInstall(data);\n    }\n\n    function _uninstallHook(\n        address hook,\n        bytes calldata data\n    ) internal virtual {\n        _setHook(address(0));\n        IHook(hook).onUninstall(data);\n    }\n\n    function _getHook() internal view returns (address _hook) {\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\n        assembly {\n            _hook := sload(slot)\n        }\n    }\n\n    function _isHookInstalled(address module) internal view returns (bool) {\n        return _getHook() == module;\n    }\n\n    function getActiveHook() external view returns (address hook) {\n        return _getHook();\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/core/ModuleManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {SentinelListLib, SENTINEL} from \"../libs/SentinelList.sol\";\nimport {CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC} from \"../libs/ModeLib.sol\";\nimport {AccountBase} from \"./AccountBase.sol\";\nimport \"../interfaces/IERC7579Module.sol\";\nimport \"forge-std/interfaces/IERC165.sol\";\nimport \"./Receiver.sol\";\nimport {ArrayLib} from \"../../libraries/ArrayLib.sol\";\n\n/**\n * @title ModuleManager\n * @author zeroknots.eth | rhinestone.wtf\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\n * @dev it uses SentinelList to manage the linked list of modules\n * NOTE: the linked list is just an example. accounts may implement this differently\n */\nabstract contract ModuleManager is AccountBase, Receiver {\n    using SentinelListLib for SentinelListLib.SentinelList;\n\n    error InvalidModule(address module);\n    error NoFallbackHandler(bytes4 selector);\n    error CannotRemoveLastValidator();\n    error FallbackInvalidCallType();\n    error InvalidFallbackCaller(address caller);\n\n    // keccak256(\"modulemanager.storage.msa\");\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\n        0xf88ce1fdb7fb1cbd3282e49729100fa3f2d6ee9f797961fe4fb1871cea89ea02;\n\n    struct FallbackHandler {\n        address handler;\n        CallType calltype;\n        address[] allowedCallers;\n    }\n\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\n    struct ModuleManagerStorage {\n        // linked list of validators. List is initialized by initializeAccount()\n        SentinelListLib.SentinelList $validators;\n        // linked list of executors. List is initialized by initializeAccount()\n        SentinelListLib.SentinelList $executors;\n        // single fallback handler for all fallbacks\n        // account vendors may implement this differently. This is just a reference implementation\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\n    }\n\n    function $moduleManager()\n        internal\n        pure\n        virtual\n        returns (ModuleManagerStorage storage $ims)\n    {\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\n        assembly {\n            $ims.slot := position\n        }\n    }\n\n    modifier onlyExecutorModule() {\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\n            .$executors;\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\n        _;\n    }\n\n    modifier onlyValidatorModule(address validator) {\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\n            .$validators;\n        if (!$validators.contains(validator)) revert InvalidModule(validator);\n        _;\n    }\n\n    function _initModuleManager() internal virtual {\n        ModuleManagerStorage storage $ims = $moduleManager();\n        $ims.$executors.init();\n        $ims.$validators.init();\n    }\n\n    function isAlreadyInitialized() internal view virtual returns (bool) {\n        ModuleManagerStorage storage $ims = $moduleManager();\n        return $ims.$validators.alreadyInitialized();\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Validators\n    ////////////////////////////////////////////////////\n    function _installValidator(\n        address validator,\n        bytes calldata data\n    ) internal virtual {\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\n            .$validators;\n        $validators.push(validator);\n        IValidator(validator).onInstall(data);\n    }\n\n    function _uninstallValidator(\n        address validator,\n        bytes calldata data\n    ) internal {\n        // TODO: check if its the last validator. this might brick the account\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\n            .$validators;\n        (address prev, bytes memory disableModuleData) = abi.decode(\n            data,\n            (address, bytes)\n        );\n        $validators.pop(prev, validator);\n        IValidator(validator).onUninstall(disableModuleData);\n    }\n\n    function _isValidatorInstalled(\n        address validator\n    ) internal view virtual returns (bool) {\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\n            .$validators;\n        return $validators.contains(validator);\n    }\n\n    /**\n     * THIS IS NOT PART OF THE STANDARD\n     * Helper Function to access linked list\n     */\n    function getValidatorPaginated(\n        address cursor,\n        uint256 size\n    ) external view virtual returns (address[] memory array, address next) {\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\n            .$validators;\n        return $validators.getEntriesPaginated(cursor, size);\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Executors\n    ////////////////////////////////////////////////////\n\n    function _installExecutor(address executor, bytes calldata data) internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\n            .$executors;\n        $executors.push(executor);\n        IExecutor(executor).onInstall(data);\n    }\n\n    function _uninstallExecutor(\n        address executor,\n        bytes calldata data\n    ) internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\n            .$executors;\n        (address prev, bytes memory disableModuleData) = abi.decode(\n            data,\n            (address, bytes)\n        );\n        $executors.pop(prev, executor);\n        IExecutor(executor).onUninstall(disableModuleData);\n    }\n\n    function _isExecutorInstalled(\n        address executor\n    ) internal view virtual returns (bool) {\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\n            .$executors;\n        return $executors.contains(executor);\n    }\n\n    /**\n     * THIS IS NOT PART OF THE STANDARD\n     * Helper Function to access linked list\n     */\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    ) external view virtual returns (address[] memory array, address next) {\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\n            .$executors;\n        return $executors.getEntriesPaginated(cursor, size);\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Fallback\n    ////////////////////////////////////////////////////\n\n    function _installFallbackHandler(\n        address handler,\n        bytes calldata params\n    ) internal virtual {\n        bytes memory _params = params;\n        bytes4 selector;\n        CallType calltype;\n        address[] memory allowedCallers;\n        bytes memory initData;\n        assembly {\n            let configPtr := add(params.offset, 0x20)\n            let configLen := calldataload(params.offset)\n\n            selector := calldataload(params.offset)\n            calltype := calldataload(configPtr)\n\n            let allowedCallersLen := calldataload(add(configPtr, 0x20))\n\n            allowedCallers := mload(0x40)\n            mstore(\n                0x40,\n                add(\n                    allowedCallers,\n                    and(add(mul(allowedCallersLen, 0x20), 0x1f), not(0x1f))\n                )\n            )\n\n            for {\n                let i := 0\n            } lt(i, allowedCallersLen) {\n                i := add(i, 1)\n            } {\n                mstore(\n                    add(allowedCallers, mul(i, 0x20)),\n                    calldataload(add(configPtr, add(0x60, mul(i, 0x20))))\n                )\n            }\n\n            let initDataPos := calldataload(add(configPtr, 0x40))\n            let initDataLen := calldataload(\n                sub(add(configPtr, initDataPos), 0x20)\n            )\n            let initDataPtr := 0x60\n            mstore(initDataPtr, initDataLen)\n            calldatacopy(\n                add(initDataPtr, 0x20),\n                add(configPtr, initDataPos),\n                initDataLen\n            )\n            initData := initDataPtr\n        }\n\n        if (calltype == CALLTYPE_DELEGATECALL) revert FallbackInvalidCallType();\n\n        if (_isFallbackHandlerInstalled(selector)) {\n            revert(\"Function selector already used\");\n        }\n        $moduleManager().$fallbacks[selector] = FallbackHandler(\n            handler,\n            calltype,\n            allowedCallers\n        );\n        IFallback(handler).onInstall(initData);\n    }\n\n    function _uninstallFallbackHandler(\n        address handler,\n        bytes calldata deInitData\n    ) internal virtual {\n        bytes4 selector = bytes4(deInitData[0:4]);\n        bytes memory _deInitData = deInitData[4:];\n\n        if (!_isFallbackHandlerInstalled(selector)) {\n            revert(\"Function selector not used\");\n        }\n\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[\n            selector\n        ];\n\n        if (activeFallback.handler != handler) {\n            revert(\"Function selector not used by this handler\");\n        }\n\n        CallType callType = activeFallback.calltype;\n\n        if (callType == CALLTYPE_DELEGATECALL) revert FallbackInvalidCallType();\n        address[] memory allowedCallers = new address[](0);\n        $moduleManager().$fallbacks[selector] = FallbackHandler(\n            address(0),\n            CallType.wrap(0x00),\n            allowedCallers\n        );\n\n        IFallback(handler).onUninstall(_deInitData);\n    }\n\n    function _isFallbackHandlerInstalled(\n        bytes4 functionSig\n    ) internal view virtual returns (bool) {\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[\n            functionSig\n        ];\n        return $fallback.handler != address(0);\n    }\n\n    function _isFallbackHandlerInstalled(\n        bytes4 functionSig,\n        address _handler\n    ) internal view virtual returns (bool) {\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[\n            functionSig\n        ];\n        return $fallback.handler == _handler;\n    }\n\n    function getActiveFallbackHandler(\n        bytes4 functionSig\n    ) external view virtual returns (FallbackHandler memory) {\n        return $moduleManager().$fallbacks[functionSig];\n    }\n\n    // validates that the caller is allowed and reverts if not.\n\n    function _validateCaller(bytes4 sig) private view {\n        address[] memory allowed = $moduleManager()\n            .$fallbacks[sig]\n            .allowedCallers;\n        if (ArrayLib._contains(allowed, msg.sender) == false) {\n            revert InvalidFallbackCaller(msg.sender);\n        }\n    }\n\n    // FALLBACK\n    // calling _validateCaller()\n\n    fallback() external payable override(Receiver) {\n        _validateCaller(msg.sig);\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[\n            msg.sig\n        ];\n        address handler = $fallbackHandler.handler;\n        CallType calltype = $fallbackHandler.calltype;\n\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\n\n        if (calltype == CALLTYPE_STATIC) {\n            assembly {\n                function allocate(length) -> pos {\n                    pos := mload(0x40)\n                    mstore(0x40, add(pos, length))\n                }\n\n                let calldataPtr := allocate(calldatasize())\n                calldatacopy(calldataPtr, 0, calldatasize())\n\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n                // Then the address without padding is stored right after the calldata\n                let senderPtr := allocate(20)\n                mstore(senderPtr, shl(96, caller()))\n\n                // Add 20 bytes for the address appended add the end\n                let success := staticcall(\n                    gas(),\n                    handler,\n                    calldataPtr,\n                    add(calldatasize(), 20),\n                    0,\n                    0\n                )\n\n                let returnDataPtr := allocate(returndatasize())\n                returndatacopy(returnDataPtr, 0, returndatasize())\n                if iszero(success) {\n                    revert(returnDataPtr, returndatasize())\n                }\n                return(returnDataPtr, returndatasize())\n            }\n        }\n        if (calltype == CALLTYPE_SINGLE) {\n            assembly {\n                function allocate(length) -> pos {\n                    pos := mload(0x40)\n                    mstore(0x40, add(pos, length))\n                }\n\n                let calldataPtr := allocate(calldatasize())\n                calldatacopy(calldataPtr, 0, calldatasize())\n\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n                // Then the address without padding is stored right after the calldata\n                let senderPtr := allocate(20)\n                mstore(senderPtr, shl(96, caller()))\n\n                // Add 20 bytes for the address appended add the end\n                let success := call(\n                    gas(),\n                    handler,\n                    0,\n                    calldataPtr,\n                    add(calldatasize(), 20),\n                    0,\n                    0\n                )\n\n                let returnDataPtr := allocate(returndatasize())\n                returndatacopy(returnDataPtr, 0, returndatasize())\n                if iszero(success) {\n                    revert(returnDataPtr, returndatasize())\n                }\n                return(returnDataPtr, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/core/Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title Receiver\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\n * @author Modified from Solady\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\n */\nabstract contract Receiver {\n    /// @dev For receiving ETH.\n    receive() external payable virtual {}\n\n    /// @dev Fallback function with the `receiverFallback` modifier.\n    fallback() external payable virtual {}\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IERC7579Account.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { CallType, ExecType, ModeCode } from \"../libs/ModeLib.sol\";\nimport {PackedUserOperation} from \"../../../../account-abstraction/contracts/interfaces/IAccount.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *      The implementation of the function is OPTIONAL\n     *\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\n     */\n    function executeUserOp(PackedUserOperation calldata userOp) external payable;\n\n    /**\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * this validation function should decode / sload the validator module to validate the userOp\n     * and call it.\n     *\n     * @dev MSA MUST implement this function signature.\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        returns (uint256 validSignature);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IERC7579Module.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {PackedUserOperation} from \"../../../../account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n    function postCheck(bytes calldata hookData) external returns (bool success);\n}\n\ninterface IFallback is IModule { }"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IMSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IERC7579Account} from \"./IERC7579Account.sol\";\n\nimport {CallType, ExecType, ModeCode} from \"../libs/ModeLib.sol\";\n\ninterface IMSA is IERC7579Account {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleType);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    // Error thrown when account initialization fails\n    error AccountInitializationFailed();\n\n    /**\n     * @dev Initializes the account. Function might be called directly, or by a Factory\n     * @param data. encoded data that can be used during the initialization phase\n     */\n    function initializeAccount(bytes calldata data) external payable;\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/libs/ExecutionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Execution} from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n */\nlibrary ExecutionLib {\n    function decodeBatch(\n        bytes calldata callData\n    ) internal pure returns (Execution[] calldata executionBatch) {\n        /*\n         * Batch Call Calldata Layout\n         * Offset (in bytes)    | Length (in bytes) | Contents\n         * 0x0                  | 0x4               | bytes4 function selector\n        *  0x4                  | -                 |\n        abi.encode(IERC7579Execution.Execution[])\n         */\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            let dataPointer := add(\n                callData.offset,\n                calldataload(callData.offset)\n            )\n\n            // Extract the ERC7579 Executions\n            executionBatch.offset := add(dataPointer, 32)\n            executionBatch.length := calldataload(dataPointer)\n        }\n    }\n\n    function encodeBatch(\n        Execution[] memory executions\n    ) internal pure returns (bytes memory callData) {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(\n        bytes calldata executionCalldata\n    )\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    ) internal pure returns (bytes memory userOpCalldata) {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/libs/ModeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/libs/SentinelList.sol": {
      "content": "// https://github.com/zeroknots/sentinellist/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\naddress constant SENTINEL = address(0x1);\naddress constant ZERO_ADDRESS = address(0x0);\n\nlibrary SentinelListLib {\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    function alreadyInitialized(\n        SentinelList storage self\n    ) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    function getNext(\n        SentinelList storage self,\n        address entry\n    ) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS)\n            revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    function pop(\n        SentinelList storage self,\n        address prevEntry,\n        address popEntry\n    ) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry)\n            revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    function contains(\n        SentinelList storage self,\n        address entry\n    ) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    ) internal view returns (address[] memory array, address next) {\n        if (start != SENTINEL && contains(self, start))\n            revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (\n            next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize\n        ) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a start.\n         */\n        if (next != SENTINEL) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/test/Bootstrap.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Bootstrap, BootstrapConfig} from \"../utils/Bootstrap.sol\";\nimport {IModule} from \"../../erc7579-ref-impl/interfaces/IERC7579Module.sol\";\n\ncontract BootstrapUtil {\n    Bootstrap bootstrapSingleton;\n\n    constructor() {\n        bootstrapSingleton = new Bootstrap();\n    }\n\n    function _makeBootstrapConfig(\n        address module,\n        bytes memory data\n    ) public pure returns (BootstrapConfig memory config) {\n        config.module = module;\n        config.data = abi.encodeCall(IModule.onInstall, data);\n    }\n\n    function makeBootstrapConfig(\n        address module,\n        bytes memory data\n    ) public pure returns (BootstrapConfig[] memory config) {\n        config = new BootstrapConfig[](1);\n        config[0].module = module;\n        config[0].data = abi.encodeCall(IModule.onInstall, data);\n    }\n\n    function makeBootstrapConfig(\n        address[] memory modules,\n        bytes[] memory datas\n    ) public pure returns (BootstrapConfig[] memory configs) {\n        configs = new BootstrapConfig[](modules.length);\n\n        for (uint256 i; i < modules.length; i++) {\n            configs[i] = _makeBootstrapConfig(modules[i], datas[i]);\n        }\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/erc7579-ref-impl/utils/Bootstrap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"../core/ModuleManager.sol\";\nimport \"../core/HookManager.sol\";\n\nimport \"../interfaces/IERC7579Module.sol\";\n\nstruct BootstrapConfig {\n    address module;\n    bytes data;\n}\n\ncontract Bootstrap is ModuleManager, HookManager {\n    function singleInitMSA(IModule validator, bytes calldata data) external {\n        // init validator\n        _installValidator(address(validator), data);\n    }\n\n    /**\n     * This function is intended to be called by the MSA with a delegatecall.\n     * Make sure that the MSA already initilazed the linked lists in the ModuleManager prior to\n     * calling this function\n     */\n    function initMSA(\n        BootstrapConfig[] calldata $valdiators,\n        BootstrapConfig[] calldata $executors,\n        BootstrapConfig calldata _hook,\n        BootstrapConfig[] calldata _fallbacks\n    )\n        external\n    {\n        // init validators\n        for (uint256 i; i < $valdiators.length; i++) {\n            _installValidator($valdiators[i].module, $valdiators[i].data);\n        }\n\n        // init executors\n        for (uint256 i; i < $executors.length; i++) {\n            if ($executors[i].module == address(0)) continue;\n            _installExecutor($executors[i].module, $executors[i].data);\n        }\n\n        // init hook\n        if (_hook.module != address(0)) {\n            _installHook(_hook.module, _hook.data);\n        }\n\n        // init fallback\n        for (uint256 i; i < _fallbacks.length; i++) {\n            if (_fallbacks[i].module == address(0)) continue;\n            _installFallbackHandler(_fallbacks[i].module, _fallbacks[i].data);\n        }\n    }\n\n    function _getInitMSACalldata(\n        BootstrapConfig[] calldata $valdiators,\n        BootstrapConfig[] calldata $executors,\n        BootstrapConfig calldata _hook,\n        BootstrapConfig[] calldata _fallbacks\n    )\n        external\n        view\n        returns (bytes memory init)\n    {\n        init = abi.encode(\n            address(this),\n            abi.encodeCall(this.initMSA, ($valdiators, $executors, _hook, _fallbacks))\n        );\n    }\n}"
    },
    "src/modular-etherspot-wallet/interfaces/IAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ninterface IAccessController {\n    /// Structs\n    struct NewOwnerProposal {\n        address newOwnerProposed;\n        bool resolved;\n        address[] guardiansApproved;\n        uint256 approvalCount;\n        uint256 proposedAt;\n    }\n\n    /// Events\n    event OwnerAdded(address account, address newOwner);\n    event OwnerRemoved(address account, address removedOwner);\n    event GuardianAdded(address account, address newGuardian);\n    event GuardianRemoved(address account, address removedGuardian);\n    event ProposalSubmitted(\n        address account,\n        uint256 proposalId,\n        address newOwnerProposed,\n        address proposer\n    );\n    event QuorumNotReached(\n        address account,\n        uint256 proposalId,\n        address newOwnerProposed,\n        uint256 approvalCount\n    );\n    event ProposalDiscarded(\n        address account,\n        uint256 proposalId,\n        address discardedBy\n    );\n\n    /// External\n    function addOwner(address _newOwner) external;\n\n    function removeOwner(address _owner) external;\n\n    function addGuardian(address _newGuardian) external;\n\n    function removeGuardian(address _guardian) external;\n\n    function changeProposalTimelock(uint256 _newTimelock) external;\n\n    function discardCurrentProposal() external;\n\n    function guardianPropose(address _newOwner) external;\n\n    function guardianCosign() external;\n\n    /// Views\n    function isOwner(address _address) external view returns (bool);\n\n    function isGuardian(address _address) external view returns (bool);\n\n    function getProposal(\n        uint256 _proposalId\n    )\n        external\n        view\n        returns (\n            address ownerProposed_,\n            uint256 approvalCount_,\n            address[] memory guardiansApproved_,\n            bool resolved_,\n            uint256 proposedAt_\n        );\n}\n"
    },
    "src/modular-etherspot-wallet/interfaces/IERC20SessionKeyValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {IValidator} from \"../../../src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IERC7579Module.sol\";\nimport {IERC7579Account} from \"../../../src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IERC7579Account.sol\";\nimport {PackedUserOperation} from \"../../../account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\n\n/// @title ERC20SessionKeyValidator Interface\n/// @author Etherspot\n/// @notice This interface defines the functions and events of the ERC20SessionKeyValidator contract.\ninterface IERC20SessionKeyValidator is IValidator {\n    /// @notice Emitted when the ERC20 Session Key Validator module is installed for a wallet.\n    /// @param wallet The address of the wallet for which the module is installed.\n    event ERC20SKV_ModuleInstalled(address wallet);\n\n    /// @notice Emitted when the ERC20 Session Key Validator module is uninstalled from a wallet.\n    /// @param wallet The address of the wallet from which the module is uninstalled.\n    event ERC20SKV_ModuleUninstalled(address wallet);\n\n    /// @notice Emitted when a new session key is enabled for a wallet.\n    /// @param sessionKey The address of the session key.\n    /// @param wallet The address of the wallet for which the session key is enabled.\n    event ERC20SKV_SessionKeyEnabled(address sessionKey, address wallet);\n\n    /// @notice Emitted when a session key is disabled for a wallet.\n    /// @param sessionKey The address of the session key.\n    /// @param wallet The address of the wallet for which the session key is disabled.\n    event ERC20SKV_SessionKeyDisabled(address sessionKey, address wallet);\n\n    /// @notice Emitted when a session key is paused for a wallet.\n    /// @param sessionKey The address of the session key.\n    /// @param wallet The address of the wallet for which the session key is paused.\n    event ERC20SKV_SessionKeyPaused(address sessionKey, address wallet);\n\n    /// @notice Emitted when a session key is unpaused for a wallet.\n    /// @param sessionKey The address of the session key.\n    /// @param wallet The address of the wallet for which the session key is unpaused.\n    event ERC20SKV_SessionKeyUnpaused(address sessionKey, address wallet);\n\n    /// @notice Struct representing the data associated with a session key.\n    struct SessionData {\n        address token; // The ERC20 token contract address.\n        bytes4 interfaceId; // The interface ID of the ERC20 token contract.\n        bytes4 funcSelector; // The function selector for the allowed operation (e.g., transfer, transferFrom).\n        uint256 spendingLimit; // The maximum amount that can be spent with this session key.\n        uint48 validAfter; // The timestamp after which the session key is valid.\n        uint48 validUntil; // The timestamp until which the session key is valid.\n        bool paused; // Flag indicating whether the session key is paused or not.\n    }\n\n    /// @notice Enables a new session key for the caller's wallet.\n    /// @param _sessionData The encoded session data containing the session key address, token address, interface ID, function selector, spending limit, valid after timestamp, and valid until timestamp.\n    function enableSessionKey(bytes calldata _sessionData) external;\n\n    /// @notice Disables a session key for the caller's wallet.\n    /// @param _session The address of the session key to disable.\n    function disableSessionKey(address _session) external;\n\n    /// @notice Rotates a session key by disabling the old one and enabling a new one.\n    /// @param _oldSessionKey The address of the old session key to disable.\n    /// @param _newSessionData The encoded session data for the new session key.\n    function rotateSessionKey(\n        address _oldSessionKey,\n        bytes calldata _newSessionData\n    ) external;\n\n    /// @notice Toggles the pause state of a session key for the caller's wallet.\n    /// @param _sessionKey The address of the session key to toggle the pause state for.\n    function toggleSessionKeyPause(address _sessionKey) external;\n\n    /// @notice Checks if a session key is paused for the caller's wallet.\n    /// @param _sessionKey The address of the session key to check.\n    /// @return paused True if the session key is paused, false otherwise.\n    function checkSessionKeyPaused(\n        address _sessionKey\n    ) external view returns (bool paused);\n\n    /// @notice Validates the parameters of a session key for a given user operation.\n    /// @param _sessionKey The address of the session key.\n    /// @param userOp The packed user operation containing the call data.\n    /// @return valid True if the session key parameters are valid for the user operation, false otherwise.\n    function validateSessionKeyParams(\n        address _sessionKey,\n        PackedUserOperation calldata userOp\n    ) external returns (bool valid);\n\n    /// @notice Returns the list of associated session keys for the caller's wallet.\n    /// @return keys The array of associated session key addresses.\n    function getAssociatedSessionKeys()\n        external\n        view\n        returns (address[] memory keys);\n\n    /// @notice Returns the session data for a given session key and the caller's wallet.\n    /// @param _sessionKey The address of the session key.\n    /// @return data The session data struct.\n    function getSessionKeyData(\n        address _sessionKey\n    ) external view returns (SessionData memory data);\n\n    /// @notice Validates a user operation using a session key.\n    /// @param userOp The packed user operation.\n    /// @param userOpHash The hash of the user operation.\n    /// @return validationData The validation data containing the expiration time and valid after timestamp of the session key.\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external returns (uint256 validationData);\n\n    /// @notice Checks if the module type matches the validator module type.\n    /// @param moduleTypeId The module type ID to check.\n    /// @return True if the module type matches the validator module type, false otherwise.\n    function isModuleType(uint256 moduleTypeId) external pure returns (bool);\n\n    /// @notice Placeholder function for module installation.\n    /// @param data The data to pass during installation.\n    function onInstall(bytes calldata data) external;\n\n    /// @notice Placeholder function for module uninstallation.\n    /// @param data The data to pass during uninstallation.\n    function onUninstall(bytes calldata data) external;\n\n    /// @notice Reverts with a \"NotImplemented\" error.\n    /// @param sender The address of the sender.\n    /// @param hash The hash of the message.\n    /// @param data The data associated with the message.\n    /// @return A bytes4 value indicating the function is not implemented.\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    ) external view returns (bytes4);\n\n    /// @notice Reverts with a \"NotImplemented\" error.\n    /// @param smartAccount The address of the smart account.\n    /// @return True if the smart account is initialized, false otherwise.\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n"
    },
    "src/modular-etherspot-wallet/interfaces/IModularEtherspotWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {IMSA} from \"../erc7579-ref-impl/interfaces/IMSA.sol\";\nimport {IAccessController} from \"./IAccessController.sol\";\n\ninterface IModularEtherspotWallet is IMSA, IAccessController\n{\n  error OnlyProxy();\n}\n"
    },
    "src/modular-etherspot-wallet/libraries/ArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary ArrayLib {\n    function _contains(\n        address[] memory A,\n        address a\n    ) internal pure returns (bool) {\n        (, bool isIn) = _indexOf(A, a);\n        return isIn;\n    }\n\n    function _indexOf(\n        address[] memory A,\n        address a\n    ) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (0, false);\n    }\n\n    function _removeElement(\n        address[] storage _data,\n        address _element\n    ) internal {\n        uint256 length = _data.length;\n        // remove item from array and resize array\n        for (uint256 ii = 0; ii < length; ii++) {\n            if (_data[ii] == _element) {\n                if (length > 1) {\n                    _data[ii] = _data[length - 1];\n                }\n                _data.pop();\n                break;\n            }\n        }\n    }\n\n    function _removeElement(\n        address[] memory _data,\n        address _element\n    ) internal pure returns (address[] memory) {\n        address[] memory newData = new address[](_data.length - 1);\n        uint256 j;\n        for (uint256 i; i < _data.length; i++) {\n            if (_data[i] != _element) {\n                newData[j] = _data[i];\n                j++;\n            }\n        }\n        return newData;\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/libraries/ErrorsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary ErrorsLib {\n    /// AccessController\n    error OnlyOwnerOrSelf();\n    error OnlyGuardian();\n    error OnlyOwnerOrGuardianOrSelf();\n\n    error AddingInvalidOwner();\n    error RemovingInvalidOwner();\n    error AddingInvalidGuardian();\n    error RemovingInvalidGuardian();\n\n    error WalletNeedsOwner();\n    error NotEnoughGuardians();\n\n    error ProposalResolved();\n    error ProposalUnresolved();\n    error AlreadySignedProposal();\n\n    error ProposalTimelocked();\n    error InvalidProposal();\n\n    // EtherspotWallet7579 Errors\n}\n"
    },
    "src/modular-etherspot-wallet/modules/executors/ERC20Actions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IFallback} from \"../../../modular-etherspot-wallet/erc7579-ref-impl/interfaces/IERC7579Module.sol\";\n\ncontract ERC20Actions is IFallback {\n    function onInstall(bytes calldata data) external override {}\n\n    function onUninstall(bytes calldata data) external override {}\n    function isModuleType(\n        uint256 moduleTypeId\n    ) external view override returns (bool) {}\n\n    function isInitialized(address _mew) external view returns (bool) {}\n    function transferERC20Action(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external {\n        IERC20(_token).transferFrom(msg.sender, _to, _amount);\n    }\n\n    function invalidERC20Action() public pure returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/modules/hooks/ModuleIsolationHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n/// @title ModuleIsolationHook\n/// @author windowhan (https://github.com/windowhan) (modifications by lbw33)\n/// @notice Custom hook to prevent modules from installing/uninstalling other modules\n/// @dev Implements preCheck hook to block restricted function calls\n\nimport {ModularEtherspotWallet} from \"../../wallet/ModularEtherspotWallet.sol\";\nimport \"../../erc7579-ref-impl/libs/ModeLib.sol\";\nimport \"../../erc7579-ref-impl/libs/ExecutionLib.sol\";\nimport \"../../erc7579-ref-impl/interfaces/IERC7579Module.sol\";\n\ncontract ModuleIsolationHook is IHook {\n    using ModeLib for ModeCode;\n    using ExecutionLib for bytes;\n\n    /// @notice Records which modules this hook is installed for\n    mapping(address => bool) public installed;\n\n    /// @notice Called when this hook is installed for a module\n    function onInstall(bytes calldata data) external override {\n        installed[msg.sender] = true;\n    }\n\n    /// @notice Called when this hook is uninstalled for a module\n    function onUninstall(bytes calldata data) external override {\n        installed[msg.sender] = false;\n    }\n    /// @notice Checks if a signature is in a list\n    /// @param target Signature to check for\n    /// @param list List of signatures\n    /// @return bool True if target is in the list\n    function contains(\n        bytes4 target,\n        bytes4[] memory list\n    ) public view returns (bool) {\n        for (uint i; i < list.length; i++) {\n            if (target == list[i]) return true;\n        }\n        return false;\n    }\n\n    /// @notice Main pre-call check for restricted signatures\n    /// @param msgSender Message sender address\n    /// @param msgData Message data\n    function preCheck(\n        address msgSender,\n        bytes calldata msgData\n    ) external override returns (bytes memory hookData) {\n        bytes4 firstFuncSig = bytes4(msgData[0:4]);\n        if (\n            firstFuncSig == ModularEtherspotWallet.executeFromExecutor.selector\n        ) {\n            ModeCode mode = ModeCode.wrap(bytes32(msgData[4:36]));\n            (CallType callType, ExecType execType, , ) = mode.decode();\n            integrityCheck(callType, msgData[68 + 32:]);\n        }\n        return \"\";\n    }\n\n    /// @notice Checks message data and reverts on restricted signatures\n    /// @param callType Call type\n    /// @param executionCallData Call data\n    function integrityCheck(\n        CallType callType,\n        bytes calldata executionCallData\n    ) public {\n        bytes4[] memory bannedSigs = new bytes4[](5);\n        bannedSigs[0] = ModularEtherspotWallet.execute.selector;\n        bannedSigs[1] = ModularEtherspotWallet.executeFromExecutor.selector;\n        bannedSigs[2] = ModularEtherspotWallet.executeUserOp.selector;\n        bannedSigs[3] = ModularEtherspotWallet.installModule.selector;\n        bannedSigs[4] = ModularEtherspotWallet.uninstallModule.selector;\n\n        if (callType == CALLTYPE_BATCH) {\n            Execution[] calldata executions = executionCallData.decodeBatch();\n            for (uint i; i < executions.length; i++) {\n                bytes4 checkSig = bytes4(executions[i].callData[0]) |\n                    (bytes4(executions[i].callData[1]) >> 8) |\n                    (bytes4(executions[i].callData[2]) >> 16) |\n                    (bytes4(executions[i].callData[3]) >> 24);\n                require(\n                    !contains(checkSig, bannedSigs),\n                    \"MEW::ModuleIsolationHook:BannedSignature\"\n                );\n            }\n        } else if (callType == CALLTYPE_SINGLE) {\n            (\n                address target,\n                uint256 value,\n                bytes calldata callData\n            ) = executionCallData.decodeSingle();\n\n            bytes4 checkSig = bytes4(callData[0]) |\n                (bytes4(callData[1]) >> 8) |\n                (bytes4(callData[2]) >> 16) |\n                (bytes4(callData[3]) >> 24);\n            require(\n                !contains(checkSig, bannedSigs),\n                \"MEW::ModuleIsolationHook:BannedSignature\"\n            );\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            bytes4 checkSig = bytes4(executionCallData[0]) |\n                (bytes4(executionCallData[1]) >> 8) |\n                (bytes4(executionCallData[2]) >> 16) |\n                (bytes4(executionCallData[3]) >> 24);\n            require(\n                !contains(checkSig, bannedSigs),\n                \"MEW::ModuleIsolationHook:BannedSignature\"\n            );\n        }\n    }\n\n    /// @notice Main pre-call check for restricted signatures\n    /// @param hookData Message sender address\n    function postCheck(\n        bytes calldata hookData\n    ) external returns (bool success) {}\n\n    /// @notice Checks if this contract is a hook module type\n    /// @param typeID Module type ID\n    /// @return bool True if module type is HOOK\n    function isModuleType(\n        uint256 typeID\n    ) external view override returns (bool) {\n        return MODULE_TYPE_HOOK == typeID;\n    }\n\n    /// @notice Checks if this hook is installed for a wallet\n    /// @param smartAccount Wallet address\n    /// @return bool True if this hook is installed for the wallet\n    function isInitialized(\n        address smartAccount\n    ) external view override returns (bool) {\n        return installed[smartAccount];\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/modules/validators/ERC20SessionKeyValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {ECDSA} from \"solady/src/utils/ECDSA.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {MODULE_TYPE_VALIDATOR, VALIDATION_FAILED} from \"../../erc7579-ref-impl/interfaces/IERC7579Module.sol\";\nimport {PackedUserOperation} from \"../../../../account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport \"../../../../account-abstraction/contracts/core/Helpers.sol\";\nimport \"../../erc7579-ref-impl/libs/ModeLib.sol\";\nimport \"../../erc7579-ref-impl/libs/ExecutionLib.sol\";\nimport {IERC20SessionKeyValidator} from \"../../interfaces/IERC20SessionKeyValidator.sol\";\nimport {ERC20Actions} from \"../executors/ERC20Actions.sol\";\nimport {ArrayLib} from \"../../libraries/ArrayLib.sol\";\n\ncontract ERC20SessionKeyValidator is IERC20SessionKeyValidator {\n    using ModeLib for ModeCode;\n    using ExecutionLib for bytes;\n\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n    /*                  CONSTANTS                */\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n\n    string constant NAME = \"ERC20SessionKeyValidator\";\n    string constant VERSION = \"1.0.0\";\n\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n    /*                    ERRORS                 */\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n\n    error ERC20SKV_ModuleAlreadyInstalled();\n    error ERC20SKV_ModuleNotInstalled();\n    error ERC20SKV_InvalidSessionKey();\n    error ERC20SKV_InvalidToken();\n    error ERC20SKV_InvalidInterfaceId();\n    error ERC20SKV_InvalidFunctionSelector();\n    error ERC20SKV_InvalidSpendingLimit();\n    error ERC20SKV_InvalidDuration(uint256 validAfter, uint256 validUntil);\n    error ERC20SKV_SessionKeyAlreadyExists(address sessionKey);\n    error ERC20SKV_SessionKeyDoesNotExist(address session);\n    error ERC20SKV_SessionPaused(address sessionKey);\n    error ERC20SKV_UnsuportedToken();\n    error ERC20SKV_UnsupportedInterface();\n    error ERC20SKV_UnsupportedSelector(bytes4 selectorUsed);\n    error ERC20SKV_SessionKeySpendLimitExceeded();\n    error NotImplemented();\n\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n    /*                   MAPPINGS                */\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n\n    mapping(address => bool) public initialized;\n    mapping(address wallet => address[] assocSessionKeys)\n        public walletSessionKeys;\n    mapping(address sessionKey => mapping(address wallet => SessionData))\n        public sessionData;\n\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n    /*               PUBLIC/EXTERNAL             */\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function enableSessionKey(bytes calldata _sessionData) public {\n        address sessionKey = address(bytes20(_sessionData[0:20]));\n        if (sessionKey == address(0)) revert ERC20SKV_InvalidSessionKey();\n        if (\n            sessionData[sessionKey][msg.sender].validUntil != 0 &&\n            ArrayLib._contains(getAssociatedSessionKeys(), sessionKey)\n        ) revert ERC20SKV_SessionKeyAlreadyExists(sessionKey);\n        address token = address(bytes20(_sessionData[20:40]));\n        if (token == address(0)) revert ERC20SKV_InvalidToken();\n        bytes4 interfaceId = bytes4(_sessionData[40:44]);\n        if (interfaceId == bytes4(0)) revert ERC20SKV_InvalidInterfaceId();\n        bytes4 funcSelector = bytes4(_sessionData[44:48]);\n        if (funcSelector == bytes4(0))\n            revert ERC20SKV_InvalidFunctionSelector();\n        uint256 spendingLimit = uint256(bytes32(_sessionData[48:80]));\n        if (spendingLimit == 0) revert ERC20SKV_InvalidSpendingLimit();\n        uint48 validAfter = uint48(bytes6(_sessionData[80:86]));\n        uint48 validUntil = uint48(bytes6(_sessionData[86:92]));\n        if (validUntil <= validAfter || validUntil == 0 || validAfter == 0)\n            revert ERC20SKV_InvalidDuration(validAfter, validUntil);\n        sessionData[sessionKey][msg.sender] = SessionData(\n            token,\n            interfaceId,\n            funcSelector,\n            spendingLimit,\n            validAfter,\n            validUntil,\n            false\n        );\n        walletSessionKeys[msg.sender].push(sessionKey);\n        emit ERC20SKV_SessionKeyEnabled(sessionKey, msg.sender);\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function disableSessionKey(address _session) public {\n        if (sessionData[_session][msg.sender].validUntil == 0)\n            revert ERC20SKV_SessionKeyDoesNotExist(_session);\n        delete sessionData[_session][msg.sender];\n        walletSessionKeys[msg.sender] = ArrayLib._removeElement(\n            getAssociatedSessionKeys(),\n            _session\n        );\n        emit ERC20SKV_SessionKeyDisabled(_session, msg.sender);\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function rotateSessionKey(\n        address _oldSessionKey,\n        bytes calldata _newSessionData\n    ) external {\n        disableSessionKey(_oldSessionKey);\n        enableSessionKey(_newSessionData);\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function toggleSessionKeyPause(address _sessionKey) external {\n        SessionData memory sd = sessionData[_sessionKey][msg.sender];\n        if (sd.paused) {\n            sessionData[_sessionKey][msg.sender].paused = false;\n            emit ERC20SKV_SessionKeyUnpaused(_sessionKey, msg.sender);\n        } else {\n            sessionData[_sessionKey][msg.sender].paused = true;\n            emit ERC20SKV_SessionKeyPaused(_sessionKey, msg.sender);\n        }\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function checkSessionKeyPaused(\n        address _sessionKey\n    ) public view returns (bool) {\n        return sessionData[_sessionKey][msg.sender].paused;\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function validateSessionKeyParams(\n        address _sessionKey,\n        PackedUserOperation calldata userOp\n    ) public returns (bool) {\n        bytes calldata callData = userOp.callData;\n        (\n            bytes4 selector,\n            address target,\n            address to,\n            address from,\n            uint256 amount\n        ) = _digest(callData);\n\n        SessionData memory sd = sessionData[_sessionKey][msg.sender];\n        if (\n            sd.validUntil == 0 ||\n            sd.validUntil < block.timestamp ||\n            sd.validAfter == 0 ||\n            sd.validAfter > block.timestamp\n        ) revert ERC20SKV_InvalidSessionKey();\n        if (target != sd.token) revert ERC20SKV_UnsuportedToken();\n        if (IERC165(target).supportsInterface(sd.interfaceId) == false)\n            revert ERC20SKV_UnsupportedInterface();\n        if (selector != sd.funcSelector)\n            revert ERC20SKV_UnsupportedSelector(selector);\n        if (amount > sd.spendingLimit)\n            revert ERC20SKV_SessionKeySpendLimitExceeded();\n        if (checkSessionKeyPaused(_sessionKey))\n            revert ERC20SKV_SessionPaused(_sessionKey);\n        return true;\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function getAssociatedSessionKeys() public view returns (address[] memory) {\n        return walletSessionKeys[msg.sender];\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function getSessionKeyData(\n        address _sessionKey\n    ) public view returns (SessionData memory) {\n        return sessionData[_sessionKey][msg.sender];\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external override returns (uint256) {\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(userOpHash);\n        address sessionKeySigner = ECDSA.recover(ethHash, userOp.signature);\n\n        if (!validateSessionKeyParams(sessionKeySigner, userOp))\n            return VALIDATION_FAILED;\n        SessionData memory sd = sessionData[sessionKeySigner][msg.sender];\n        return _packValidationData(false, sd.validUntil, sd.validAfter);\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function isModuleType(\n        uint256 moduleTypeId\n    ) external pure override returns (bool) {\n        return moduleTypeId == MODULE_TYPE_VALIDATOR;\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function onInstall(bytes calldata data) external override {\n        if (initialized[msg.sender] == true)\n            revert ERC20SKV_ModuleAlreadyInstalled();\n        initialized[msg.sender] = true;\n        emit ERC20SKV_ModuleInstalled(msg.sender);\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function onUninstall(bytes calldata data) external override {\n        if (initialized[msg.sender] == false)\n            revert ERC20SKV_ModuleNotInstalled();\n        address[] memory sessionKeys = getAssociatedSessionKeys();\n        uint256 sessionKeysLength = sessionKeys.length;\n        for (uint256 i; i < sessionKeysLength; i++) {\n            delete sessionData[sessionKeys[i]][msg.sender];\n        }\n        delete walletSessionKeys[msg.sender];\n        initialized[msg.sender] = false;\n        emit ERC20SKV_ModuleUninstalled(msg.sender);\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    ) external view returns (bytes4) {\n        revert NotImplemented();\n    }\n\n    // @inheritdoc IERC20SessionKeyValidator\n    function isInitialized(address smartAccount) external view returns (bool) {\n        return initialized[smartAccount];\n    }\n\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n    /*                   INTERNAL                */\n    /*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*§*/\n\n    function _digest(\n        bytes calldata _data\n    )\n        internal\n        pure\n        returns (\n            bytes4 selector,\n            address targetContract,\n            address to,\n            address from,\n            uint256 amount\n        )\n    {\n        bytes4 functionSelector;\n        assembly {\n            functionSelector := calldataload(_data.offset)\n            targetContract := calldataload(add(_data.offset, 0x04))\n        }\n        if (\n            functionSelector == IERC20.approve.selector ||\n            functionSelector == IERC20.transfer.selector ||\n            functionSelector == ERC20Actions.transferERC20Action.selector\n        ) {\n            assembly {\n                targetContract := calldataload(add(_data.offset, 0x04))\n                to := calldataload(add(_data.offset, 0x24))\n                amount := calldataload(add(_data.offset, 0x44))\n            }\n            return (functionSelector, targetContract, to, address(0), amount);\n        } else if (functionSelector == IERC20.transferFrom.selector) {\n            assembly {\n                targetContract := calldataload(add(_data.offset, 0x04))\n                from := calldataload(add(_data.offset, 0x24))\n                to := calldataload(add(_data.offset, 0x44))\n                amount := calldataload(add(_data.offset, 0x64))\n            }\n            return (functionSelector, targetContract, to, from, amount);\n        } else {\n            revert ERC20SKV_UnsupportedSelector(functionSelector);\n        }\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/modules/validators/MultipleOwnerECDSAValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"../../erc7579-ref-impl/interfaces/IERC7579Account.sol\";\nimport \"../../erc7579-ref-impl/interfaces/IERC7579Module.sol\";\nimport \"../../erc7579-ref-impl/libs/ModeLib.sol\";\nimport \"../../erc7579-ref-impl/libs/ExecutionLib.sol\";\nimport {ModularEtherspotWallet} from \"../../wallet/ModularEtherspotWallet.sol\";\nimport {ECDSA} from \"solady/src/utils/ECDSA.sol\";\n\ncontract MultipleOwnerECDSAValidator is IValidator {\n    using ExecutionLib for bytes;\n    using ECDSA for bytes32;\n\n    string constant NAME = \"MultipleOwnerECDSAValidator\";\n    string constant VERSION = \"1.0.0\";\n\n    error InvalidExec();\n    error RequiredModule();\n\n    mapping(address => bool) internal _initialized;\n\n    function onInstall(bytes calldata data) external override {\n        if (isInitialized(msg.sender)) revert AlreadyInitialized(msg.sender);\n        _initialized[msg.sender] = true;\n    }\n\n    function onUninstall(bytes calldata data) external override {\n        revert RequiredModule();\n    }\n\n    function isInitialized(\n        address smartAccount\n    ) public view override returns (bool) {\n        return _initialized[smartAccount];\n    }\n\n    function isModuleType(\n        uint256 typeID\n    ) external pure override returns (bool) {\n        return typeID == MODULE_TYPE_VALIDATOR;\n    }\n\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external override returns (uint256) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        address signer = hash.recover(userOp.signature);\n        if (\n            signer == address(0) ||\n            !ModularEtherspotWallet(payable(msg.sender)).isOwner(signer)\n        ) {\n            return VALIDATION_FAILED;\n        }\n        // get the function selector that will be called by EntryPoint\n        bytes4 execFunction = bytes4(userOp.callData[:4]);\n\n        // get the mode\n        CallType callType = CallType.wrap(bytes1(userOp.callData[4]));\n        bytes calldata executionCalldata = userOp.callData[36:];\n        if (callType == CALLTYPE_BATCH) {\n            Execution[] calldata executions = executionCalldata.decodeBatch();\n        } else if (callType == CALLTYPE_SINGLE) {\n            (\n                address target,\n                uint256 value,\n                bytes calldata callData\n            ) = executionCalldata.decodeSingle();\n        }\n    }\n\n    function isValidSignatureWithSender(\n        address,\n        bytes32 hash,\n        bytes calldata data\n    ) external view override returns (bytes4) {\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(hash);\n        address owner = ECDSA.recover(ethHash, data);\n        if (ModularEtherspotWallet(payable(msg.sender)).isOwner(owner)) {\n            return 0x1626ba7e;\n        }\n        return 0xffffffff;\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/wallet/FactoryStaker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"solady/src/auth/Ownable.sol\";\nimport {IEntryPoint} from \"../../../account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n\ncontract FactoryStaker is Ownable {\n    error FactoryStaker_InvalidEPAddress();\n    constructor(address _owner) {\n        _initializeOwner(_owner);\n    }\n\n    function addStake(\n        address _epAddress,\n        uint32 _unstakeDelaySec\n    ) external payable onlyOwner {\n        if (_epAddress == address(0)) revert FactoryStaker_InvalidEPAddress();\n        IEntryPoint(_epAddress).addStake{value: msg.value}(_unstakeDelaySec);\n    }\n\n    function unlockStake(address _epAddress) external onlyOwner {\n        if (_epAddress == address(0)) revert FactoryStaker_InvalidEPAddress();\n        IEntryPoint(_epAddress).unlockStake();\n    }\n\n    function withdrawStake(\n        address _epAddress,\n        address payable _withdrawTo\n    ) external onlyOwner {\n        if (_epAddress == address(0)) revert FactoryStaker_InvalidEPAddress();\n        IEntryPoint(_epAddress).withdrawStake(_withdrawTo);\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/wallet/ModularEtherspotWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"../erc7579-ref-impl/libs/ModeLib.sol\";\nimport {ExecutionLib} from \"../erc7579-ref-impl/libs/ExecutionLib.sol\";\nimport {ExecutionHelper} from \"../erc7579-ref-impl/core/ExecutionHelper.sol\";\nimport {PackedUserOperation} from \"../../../account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport \"../erc7579-ref-impl/interfaces/IERC7579Module.sol\";\nimport {IModularEtherspotWallet} from \"../interfaces/IModularEtherspotWallet.sol\";\nimport {ModuleManager} from \"../erc7579-ref-impl/core/ModuleManager.sol\";\nimport {HookManager} from \"../erc7579-ref-impl/core/HookManager.sol\";\nimport {AccessController} from \"../access/AccessController.sol\";\n\ncontract ModularEtherspotWallet is\n    AccessController,\n    IModularEtherspotWallet,\n    ExecutionHelper,\n    ModuleManager,\n    HookManager\n{\n    using ExecutionLib for bytes;\n    using ModeLib for ModeCode;\n    address public immutable implementation = address(this);\n\n    /**\n     * @dev modifier to restrict access to calling on implementation\n     */\n    modifier onlyProxy() {\n        if (address(this) == implementation) revert OnlyProxy();\n        _;\n    }\n\n    /**\n     * @dev see {IERC7579Account}.\n     * @dev this function is only callable by the entry point or the account itself\n     * @dev this function demonstrates how to implement\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\n     * @dev this function demonstrates how to implement hook support (modifier)\n     */\n    function execute(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    ) external payable onlyEntryPointOrSelf withHook {\n        (CallType callType, ExecType execType, , ) = mode.decode();\n\n        // check if calltype is batch or single\n        if (callType == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions = executionCalldata.decodeBatch();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_SINGLE) {\n            // destructure executionCallData according to single exec\n            (\n                address target,\n                uint256 value,\n                bytes calldata callData\n            ) = executionCalldata.decodeSingle();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT)\n                _execute(target, value, callData);\n                // TODO: implement event emission for tryExecute singleCall\n            else if (execType == EXECTYPE_TRY)\n                _tryExecute(target, value, callData);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            // destructure executionCallData according to single exec\n            address delegate = address(\n                uint160(bytes20(executionCalldata[0:20]))\n            );\n            bytes calldata callData = executionCalldata[20:];\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT)\n                _executeDelegatecall(delegate, callData);\n            else if (execType == EXECTYPE_TRY)\n                _tryExecuteDelegatecall(delegate, callData);\n            else revert UnsupportedExecType(execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /**\n     * @dev see {IERC7579Account}.\n     * @dev this function is only callable by an installed executor module\n     * @dev this function demonstrates how to implement\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\n     * @dev this function demonstrates how to implement hook support (modifier)\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        onlyExecutorModule\n        withHook\n        returns (\n            bytes[] memory returnData // TODO returnData is not used\n        )\n    {\n        (CallType callType, ExecType execType, , ) = mode.decode();\n\n        // check if calltype is batch or single\n        if (callType == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions = executionCalldata.decodeBatch();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\n            else if (execType == EXECTYPE_TRY)\n                returnData = _tryExecute(executions);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_SINGLE) {\n            // destructure executionCallData according to single exec\n            (\n                address target,\n                uint256 value,\n                bytes calldata callData\n            ) = executionCalldata.decodeSingle();\n            returnData = new bytes[](1);\n            bool success;\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) {\n                returnData[0] = _execute(target, value, callData);\n            }\n            // TODO: implement event emission for tryExecute singleCall\n            else if (execType == EXECTYPE_TRY) {\n                (success, returnData[0]) = _tryExecute(target, value, callData);\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\n            } else {\n                revert UnsupportedExecType(execType);\n            }\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            // destructure executionCallData according to single exec\n            address delegate = address(\n                uint160(bytes20(executionCalldata[0:20]))\n            );\n            bytes calldata callData = executionCalldata[20:];\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT)\n                _executeDelegatecall(delegate, callData);\n            else if (execType == EXECTYPE_TRY)\n                _tryExecuteDelegatecall(delegate, callData);\n            else revert UnsupportedExecType(execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /**\n     *  @dev see {IERC7579Account}.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp\n    ) external payable onlyEntryPointOrSelf {\n        bytes calldata callData = userOp.callData[4:];\n        (bool success, ) = address(this).delegatecall(callData);\n        if (!success) revert ExecutionFailed();\n    }\n\n    /**\n     *  @dev see {IERC7579Account}.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    ) external payable onlyEntryPointOrSelf {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR)\n            _installValidator(module, initData);\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR)\n            _installExecutor(module, initData);\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _installFallbackHandler(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK)\n            _installHook(module, initData);\n        else revert UnsupportedModuleType(moduleTypeId);\n        emit ModuleInstalled(moduleTypeId, module);\n    }\n\n    /**\n     *  @dev see {IERC7579Account}.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    ) external payable onlyEntryPointOrSelf {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _uninstallValidator(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _uninstallExecutor(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _uninstallFallbackHandler(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _uninstallHook(module, deInitData);\n        } else {\n            revert UnsupportedModuleType(moduleTypeId);\n        }\n        emit ModuleUninstalled(moduleTypeId, module);\n    }\n\n    /**\n     * @dev see {IERC7579Account}.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        virtual\n        override\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validSignature)\n    {\n        address validator;\n        // @notice validator encoding in nonce is just an example!\n        // @notice this is not part of the standard!\n        // Account Vendors may choose any other way to implement validator selection\n        uint256 nonce = userOp.nonce;\n        assembly {\n            validator := shr(96, nonce)\n        }\n\n        // check if validator is enabled. If not terminate the validation phase.\n        if (!_isValidatorInstalled(validator)) return VALIDATION_FAILED;\n\n        // bubble up the return value of the validator module\n        validSignature = IValidator(validator).validateUserOp(\n            userOp,\n            userOpHash\n        );\n    }\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes calldata data\n    ) external view virtual override returns (bytes4) {\n        address validator = address(bytes20(data[0:20]));\n        if (!_isValidatorInstalled(validator)) revert InvalidModule(validator);\n        return\n            IValidator(validator).isValidSignatureWithSender(\n                msg.sender,\n                hash,\n                data[20:]\n            );\n    }\n\n    /**\n     * @dev see {IERC7579Account}.\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    ) external view override returns (bool) {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            return _isValidatorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            return\n                _isFallbackHandlerInstalled(\n                    abi.decode(additionalContext, (bytes4)),\n                    module\n                );\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     *  @dev see {IERC7579Account}.\n     */\n    function accountId()\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"etherspotwallet.modular.v1.0.0\";\n    }\n\n    /**\n     * @dev see {IERC7579Account}.\n     */\n    function supportsExecutionMode(\n        ModeCode mode\n    ) external view virtual override returns (bool isSupported) {\n        (CallType callType, ExecType execType, , ) = mode.decode();\n        if (callType == CALLTYPE_BATCH) isSupported = true;\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\n        else if (callType == CALLTYPE_DELEGATECALL)\n            isSupported = true;\n            // if callType is not single, batch or delegatecall return false\n        else return false;\n\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\n        else if (execType == EXECTYPE_TRY)\n            isSupported = true;\n            // if execType is not default or try, return false\n        else return false;\n    }\n\n    /**\n     *  @dev see {IERC7579Account}.\n     */\n    function supportsModule(\n        uint256 modulTypeId\n    ) external view virtual override returns (bool) {\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\n        else return false;\n    }\n\n    /**\n     *  @dev see {IERC7579Account}.\n     */\n    function initializeAccount(\n        bytes calldata data\n    ) public payable virtual onlyProxy {\n        _initModuleManager();\n        (address owner, address bootstrap, bytes memory bootstrapCall) = abi\n            .decode(data, (address, address, bytes));\n        _addOwner(owner);\n        (bool success, ) = bootstrap.delegatecall(bootstrapCall);\n        if (!success) revert AccountInitializationFailed();\n    }\n}\n"
    },
    "src/modular-etherspot-wallet/wallet/ModularEtherspotWalletFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport {LibClone} from \"solady/src/utils/LibClone.sol\";\nimport {IModularEtherspotWallet} from \"../interfaces/IModularEtherspotWallet.sol\";\nimport {FactoryStaker} from \"./FactoryStaker.sol\";\n\ncontract ModularEtherspotWalletFactory is FactoryStaker {\n    address public immutable implementation;\n\n    constructor(address _implementation, address _owner) FactoryStaker(_owner) {\n        implementation = _implementation;\n    }\n\n    function createAccount(\n        bytes32 salt,\n        bytes calldata initCode\n    ) public payable virtual returns (address) {\n        bytes32 _salt = _getSalt(salt, initCode);\n        (bool alreadyDeployed, address account) = LibClone\n            .createDeterministicERC1967(msg.value, implementation, _salt);\n\n        if (!alreadyDeployed) {\n            IModularEtherspotWallet(account).initializeAccount(initCode);\n        }\n        return account;\n    }\n\n    function getAddress(\n        bytes32 salt,\n        bytes calldata initcode\n    ) public view virtual returns (address) {\n        bytes32 _salt = _getSalt(salt, initcode);\n        return\n            LibClone.predictDeterministicAddressERC1967(\n                implementation,\n                _salt,\n                address(this)\n            );\n    }\n\n    function _getSalt(\n        bytes32 _salt,\n        bytes calldata initCode\n    ) public pure virtual returns (bytes32 salt) {\n        salt = keccak256(abi.encodePacked(_salt, initCode));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}