{
  "address": "0x8350355c08aDAC387b443782124A30A8942BeC2e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidExec",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "InvalidTargetAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "NotInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "eip712Domain",
      "outputs": [
        {
          "internalType": "bytes1",
          "name": "fields",
          "type": "bytes1"
        },
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "version",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "verifyingContract",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "uint256[]",
          "name": "extensions",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "typeID",
          "type": "uint256"
        }
      ],
      "name": "isModuleType",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "isValidSignatureWithSender",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onInstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onUninstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x536de98e2868f3b78baa25358515763738e00a431734106c7303171825020be6",
  "receipt": {
    "to": null,
    "from": "0x09FD4F6088f2025427AB1e89257A44747081Ed59",
    "contractAddress": "0x8350355c08aDAC387b443782124A30A8942BeC2e",
    "transactionIndex": 3,
    "gasUsed": "831454",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xfe3e02221f833361aeb374e384735ede380e7d3f2f25514d068b759935bd4a33",
    "transactionHash": "0x536de98e2868f3b78baa25358515763738e00a431734106c7303171825020be6",
    "logs": [],
    "blockNumber": 78115280,
    "cumulativeGasUsed": "1126634",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c8da6d954149a720a3d44b2e706cb1f7",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExec\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"InvalidTargetAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"NotInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeID\",\"type\":\"uint256\"}],\"name\":\"isModuleType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"isValidSignatureWithSender\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onInstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onUninstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"eip712Domain()\":{\"details\":\"See: https://eips.ethereum.org/EIPS/eip-5267\"},\"isInitialized(address)\":{\"details\":\"Returns if the module was already initialized for a provided smartaccount\"},\"onInstall(bytes)\":{\"details\":\"This function is called by the smart account during installation of the module\",\"params\":{\"data\":\"arbitrary data that may be required on the module during `onInstall` initialization MUST revert on error (i.e. if module is already enabled)\"}},\"onUninstall(bytes)\":{\"details\":\"This function is called by the smart account during uninstallation of the module\",\"params\":{\"data\":\"arbitrary data that may be required on the module during `onUninstall` de-initialization MUST revert on error\"}},\"validateUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32)\":{\"details\":\"Validates a transaction on behalf of the account.         This function is intended to be called by the MSA during the ERC-4337 validaton phase         Note: solely relying on bytes32 hash and signature is not suffcient for some validation implementations (i.e. SessionKeys often need access to userOp.calldata)\",\"params\":{\"userOp\":\"The user operation to be validated. The userOp MUST NOT contain any metadata. The MSA MUST clean up the userOp before sending it to the validator.\",\"userOpHash\":\"The hash of the user operation to be validated\"},\"returns\":{\"_0\":\"return value according to ERC-4337\"}}},\"stateVariables\":{\"EIP712_DOMAIN_TYPEHASH\":{\"details\":\"`keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/modular-etherspot-wallet/modules/validators/MultipleOwnerECDSAValidator.sol\":\"MultipleOwnerECDSAValidator\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"account-abstraction/contracts/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\ninterface IAccount {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\\n     *                              for future calls. Can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *                                 otherwise, an address of an \\\"authorizer\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0x38710bec0cb20ff4ceef46a80475b5bdabc27b7efd2687fd473db68332f61b78\",\"license\":\"GPL-3.0\"},\"account-abstraction/contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"forge-std/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    /// uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600\",\"license\":\"MIT\"},\"solady/src/utils/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// @dev Note:\\n/// - The recovery functions use the ecrecover precompile (0x1).\\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\\n///   This is for more safety by default.\\n///   Use the `tryRecover` variants if you need to get the zero address back\\n///   upon recovery failure instead.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary ECDSA {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x317f8208d1f03356e8f709eec8e2c579d6be227099a26f777cc9ec8a06814ae4\",\"license\":\"MIT\"},\"solady/src/utils/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\\n///\\n/// @dev Note, this implementation:\\n/// - Uses `address(this)` for the `verifyingContract` field.\\n/// - Does NOT use the optional EIP-712 salt.\\n/// - Does NOT use any EIP-712 extensions.\\n/// This is for simplicity and to save gas.\\n/// If you need to customize, please fork / modify accordingly.\\nabstract contract EIP712 {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  CONSTANTS AND IMMUTABLES                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    uint256 private immutable _cachedThis;\\n    uint256 private immutable _cachedChainId;\\n    bytes32 private immutable _cachedNameHash;\\n    bytes32 private immutable _cachedVersionHash;\\n    bytes32 private immutable _cachedDomainSeparator;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Cache the hashes for cheaper runtime gas costs.\\n    /// In the case of upgradeable contracts (i.e. proxies),\\n    /// or if the chain id changes due to a hard fork,\\n    /// the domain separator will be seamlessly calculated on-the-fly.\\n    constructor() {\\n        _cachedThis = uint256(uint160(address(this)));\\n        _cachedChainId = block.chainid;\\n\\n        string memory name;\\n        string memory version;\\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\\n        bytes32 versionHash =\\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\\n        _cachedNameHash = nameHash;\\n        _cachedVersionHash = versionHash;\\n\\n        bytes32 separator;\\n        if (!_domainNameAndVersionMayChange()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let m := mload(0x40) // Load the free memory pointer.\\n                mstore(m, _DOMAIN_TYPEHASH)\\n                mstore(add(m, 0x20), nameHash)\\n                mstore(add(m, 0x40), versionHash)\\n                mstore(add(m, 0x60), chainid())\\n                mstore(add(m, 0x80), address())\\n                separator := keccak256(m, 0xa0)\\n            }\\n        }\\n        _cachedDomainSeparator = separator;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   FUNCTIONS TO OVERRIDE                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Please override this function to return the domain name and version.\\n    /// ```\\n    ///     function _domainNameAndVersion()\\n    ///         internal\\n    ///         pure\\n    ///         virtual\\n    ///         returns (string memory name, string memory version)\\n    ///     {\\n    ///         name = \\\"Solady\\\";\\n    ///         version = \\\"1\\\";\\n    ///     }\\n    /// ```\\n    ///\\n    /// Note: If the returned result may change after the contract has been deployed,\\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\\n    function _domainNameAndVersion()\\n        internal\\n        view\\n        virtual\\n        returns (string memory name, string memory version);\\n\\n    /// @dev Returns if `_domainNameAndVersion()` may change\\n    /// after the contract has been deployed (i.e. after the constructor).\\n    /// Default: false.\\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\\n        if (_domainNameAndVersionMayChange()) {\\n            separator = _buildDomainSeparator();\\n        } else {\\n            separator = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\\n    /// given `structHash`, as defined in\\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\\n    ///\\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\\n    /// ```\\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\\n    ///         keccak256(\\\"Mail(address to,string contents)\\\"),\\n    ///         mailTo,\\n    ///         keccak256(bytes(mailContents))\\n    ///     )));\\n    ///     address signer = ECDSA.recover(digest, signature);\\n    /// ```\\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\\n        // We will use `digest` to store the domain separator to save a bit of gas.\\n        if (_domainNameAndVersionMayChange()) {\\n            digest = _buildDomainSeparator();\\n        } else {\\n            digest = _cachedDomainSeparator;\\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the digest.\\n            mstore(0x00, 0x1901000000000000) // Store \\\"\\\\x19\\\\x01\\\".\\n            mstore(0x1a, digest) // Store the domain separator.\\n            mstore(0x3a, structHash) // Store the struct hash.\\n            digest := keccak256(0x18, 0x42)\\n            // Restore the part of the free memory slot that was overwritten.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    EIP-5267 OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\\n    function eip712Domain()\\n        public\\n        view\\n        virtual\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        fields = hex\\\"0f\\\"; // `0b01111`.\\n        (name, version) = _domainNameAndVersion();\\n        chainId = block.chainid;\\n        verifyingContract = address(this);\\n        salt = salt; // `bytes32(0)`.\\n        extensions = extensions; // `new uint256[](0)`.\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the EIP-712 domain separator.\\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\\n        // We will use `separator` to store the name hash to save a bit of gas.\\n        bytes32 versionHash;\\n        if (_domainNameAndVersionMayChange()) {\\n            (string memory name, string memory version) = _domainNameAndVersion();\\n            separator = keccak256(bytes(name));\\n            versionHash = keccak256(bytes(version));\\n        } else {\\n            separator = _cachedNameHash;\\n            versionHash = _cachedVersionHash;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Load the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), separator) // Name hash.\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            separator := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /// @dev Returns if the cached domain separator has been invalidated.\\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\\n        uint256 cachedChainId = _cachedChainId;\\n        uint256 cachedThis = _cachedThis;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb5c4c8ac5368c9785b4e30314f4ad6f3ae13bdc21679007735681d13da797bec\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/access/AccessController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IAccessController} from \\\"../interfaces/IAccessController.sol\\\";\\nimport {ErrorsLib} from \\\"../libraries/ErrorsLib.sol\\\";\\n\\ncontract AccessController is IAccessController {\\n    /// State Variables\\n    uint128 constant MULTIPLY_FACTOR = 1000;\\n    uint16 constant SIXTY_PERCENT = 600;\\n    uint24 constant INITIAL_PROPOSAL_TIMELOCK = 24 hours;\\n    uint256 public ownerCount;\\n    uint256 public guardianCount;\\n    uint256 public proposalId;\\n    uint256 public proposalTimelock;\\n\\n    /// Mappings\\n    mapping(address => bool) private _owners;\\n    mapping(address => bool) private _guardians;\\n    mapping(uint256 => NewOwnerProposal) private _proposals;\\n\\n    /// Modifiers\\n    modifier onlyOwnerOrSelf() {\\n        if (!(isOwner(msg.sender) || msg.sender == address(this))) {\\n            revert ErrorsLib.OnlyOwnerOrSelf();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyGuardian() {\\n        if (!isGuardian(msg.sender)) {\\n            revert ErrorsLib.OnlyGuardian();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrGuardianOrSelf() {\\n        if (\\n            !(isOwner(msg.sender) ||\\n                isGuardian(msg.sender) ||\\n                msg.sender == address(this))\\n        ) {\\n            revert ErrorsLib.OnlyOwnerOrGuardianOrSelf();\\n        }\\n        _;\\n    }\\n\\n    /// External\\n    /**\\n     * @notice Add owner to the wallet.\\n     * @dev Only owner or wallet.\\n     * @param _newOwner address of new owner to add.\\n     */\\n    function addOwner(address _newOwner) external onlyOwnerOrSelf {\\n        if (\\n            _newOwner == address(0) ||\\n            isGuardian(_newOwner) ||\\n            isOwner(_newOwner)\\n        ) {\\n            revert ErrorsLib.AddingInvalidOwner();\\n        }\\n        _addOwner(_newOwner);\\n        emit OwnerAdded(address(this), _newOwner);\\n    }\\n\\n    /**\\n     * @notice Remove owner from wallet.\\n     * @dev Only owner or wallet.\\n     * @param _owner address of wallet owner to remove .\\n     */\\n    function removeOwner(address _owner) external onlyOwnerOrSelf {\\n        if (!isOwner(_owner)) revert ErrorsLib.RemovingInvalidOwner();\\n        if (ownerCount <= 1) {\\n            revert ErrorsLib.WalletNeedsOwner();\\n        }\\n        _removeOwner(_owner);\\n        emit OwnerRemoved(address(this), _owner);\\n    }\\n\\n    /**\\n     * @notice Add guardian for the wallet.\\n     * @dev Only owner or wallet.\\n     * @param _newGuardian address of new guardian to add to wallet.\\n     */\\n    function addGuardian(address _newGuardian) external onlyOwnerOrSelf {\\n        if (\\n            _newGuardian == address(0) ||\\n            isGuardian(_newGuardian) ||\\n            isOwner(_newGuardian)\\n        ) {\\n            revert ErrorsLib.AddingInvalidGuardian();\\n        }\\n        _addGuardian(_newGuardian);\\n        emit GuardianAdded(address(this), _newGuardian);\\n    }\\n\\n    /**\\n     * @notice Remove guardian from the wallet.\\n     * @dev Only owner or wallet.\\n     * @param _guardian address of existing guardian to remove.\\n     */\\n    function removeGuardian(address _guardian) external onlyOwnerOrSelf {\\n        if (!isGuardian(_guardian)) revert ErrorsLib.RemovingInvalidGuardian();\\n        _removeGuardian(_guardian);\\n        emit GuardianRemoved(address(this), _guardian);\\n    }\\n\\n    /**\\n     * @notice Change the timelock on proposals.\\n     * The minimum time (secs) that a proposal is allowed to be discarded.\\n     * @dev Only owner or wallet.\\n     * @param   _newTimelock new timelock in seconds.\\n     */\\n    function changeProposalTimelock(\\n        uint256 _newTimelock\\n    ) external onlyOwnerOrSelf {\\n        assembly {\\n            sstore(proposalTimelock.slot, _newTimelock)\\n        }\\n    }\\n\\n    /**\\n     * @notice Discards the current proposal.\\n     * @dev Only owner or guardian or wallet. Must be after the proposal timelock is met.\\n     */\\n    function discardCurrentProposal() public onlyOwnerOrGuardianOrSelf {\\n        NewOwnerProposal storage prop = _proposals[proposalId];\\n        uint256 timelock = proposalTimelock == 0\\n            ? INITIAL_PROPOSAL_TIMELOCK\\n            : proposalTimelock;\\n        if (_resolvedProposal()) {\\n            revert ErrorsLib.ProposalResolved();\\n        }\\n        bool allowed = isGuardian(msg.sender);\\n        if (allowed && (prop.proposedAt + timelock >= block.timestamp))\\n            revert ErrorsLib.ProposalTimelocked();\\n\\n        prop.resolved = true;\\n        emit ProposalDiscarded(address(this), proposalId, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Creates a new owner proposal (adds new owner to wallet).\\n     * @dev Only guardian.\\n     * @param _newOwner the proposed new owner for the wallet.\\n     */\\n    function guardianPropose(address _newOwner) external onlyGuardian {\\n        if (\\n            _newOwner == address(0) ||\\n            isGuardian(_newOwner) ||\\n            isOwner(_newOwner)\\n        ) {\\n            revert ErrorsLib.AddingInvalidOwner();\\n        }\\n        if (guardianCount < 3) {\\n            revert ErrorsLib.NotEnoughGuardians();\\n        }\\n        NewOwnerProposal storage prop = _proposals[proposalId];\\n        if (prop.guardiansApproved.length != 0 && !prop.resolved) {\\n            revert ErrorsLib.ProposalUnresolved();\\n        }\\n        uint256 newProposalId = proposalId + 1;\\n        _proposals[newProposalId].newOwnerProposed = _newOwner;\\n        _proposals[newProposalId].guardiansApproved.push(msg.sender);\\n        _proposals[newProposalId].approvalCount++;\\n        _proposals[newProposalId].resolved = false;\\n        _proposals[newProposalId].proposedAt = block.timestamp;\\n        proposalId = newProposalId;\\n        emit ProposalSubmitted(\\n            address(this),\\n            newProposalId,\\n            _newOwner,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @notice Cosigns a new owner proposal.\\n     * @dev Only guardian. Must meet minimum threshold of 60% of total guardians to add new owner.\\n     */\\n    function guardianCosign() external onlyGuardian {\\n        uint256 latestId = proposalId;\\n        NewOwnerProposal storage latestProp = _proposals[latestId];\\n        if (latestId == 0) {\\n            revert ErrorsLib.InvalidProposal();\\n        }\\n        if (_checkIfSigned(latestId)) {\\n            revert ErrorsLib.AlreadySignedProposal();\\n        }\\n        if (_resolvedProposal()) {\\n            revert ErrorsLib.ProposalResolved();\\n        }\\n        _proposals[latestId].guardiansApproved.push(msg.sender);\\n        _proposals[latestId].approvalCount++;\\n        address newOwner = latestProp.newOwnerProposed;\\n        if (_checkQuorumReached(latestId)) {\\n            _proposals[latestId].resolved = true;\\n            _addOwner(newOwner);\\n        } else {\\n            emit QuorumNotReached(\\n                address(this),\\n                latestId,\\n                newOwner,\\n                _proposals[latestId].approvalCount\\n            );\\n        }\\n    }\\n\\n    /// Views\\n    /**\\n     * @notice Checks if _address is owner of wallet.\\n     * @param _address address to check if owner of wallet.\\n     * @return  bool.\\n     */\\n    function isOwner(address _address) public view returns (bool) {\\n        return _owners[_address];\\n    }\\n\\n    /**\\n     * @notice Checks if _address is guardian of wallet.\\n     * @param _address address to check if guardian of wallet.\\n     * @return  bool.\\n     */\\n    function isGuardian(address _address) public view returns (bool) {\\n        return _guardians[_address];\\n    }\\n\\n    /**\\n     * @notice Returns new owner proposal data.\\n     * @param _proposalId proposal id to return data for.\\n     * @return ownerProposed_ the new owner proposed.\\n     * @return approvalCount_ number of guardians that have approved the proposal.\\n     * @return guardiansApproved_ array of guardian addresses that have approved proposal.\\n     * @return resolved_ bool is the proposal resolved.\\n     * @return proposedAt_ timestamp of when proposal was initiated.\\n     */\\n    function getProposal(\\n        uint256 _proposalId\\n    )\\n        public\\n        view\\n        returns (\\n            address ownerProposed_,\\n            uint256 approvalCount_,\\n            address[] memory guardiansApproved_,\\n            bool resolved_,\\n            uint256 proposedAt_\\n        )\\n    {\\n        if (_proposalId == 0 || _proposalId > proposalId) {\\n            revert ErrorsLib.InvalidProposal();\\n        }\\n        NewOwnerProposal memory proposal = _proposals[_proposalId];\\n        return (\\n            proposal.newOwnerProposed,\\n            proposal.approvalCount,\\n            proposal.guardiansApproved,\\n            proposal.resolved,\\n            proposal.proposedAt\\n        );\\n    }\\n\\n    /// Internal\\n    function _addOwner(address _newOwner) internal {\\n        _owners[_newOwner] = true;\\n        ownerCount++;\\n    }\\n\\n    function _addGuardian(address _newGuardian) internal {\\n        _guardians[_newGuardian] = true;\\n        guardianCount++;\\n        if (!_resolvedProposal()) discardCurrentProposal();\\n    }\\n\\n    function _removeOwner(address _owner) internal {\\n        _owners[_owner] = false;\\n        ownerCount--;\\n    }\\n\\n    function _removeGuardian(address _guardian) internal {\\n        _guardians[_guardian] = false;\\n        guardianCount--;\\n        if (!_resolvedProposal()) discardCurrentProposal();\\n    }\\n\\n    function _checkIfSigned(uint256 _proposalId) internal view returns (bool) {\\n        for (\\n            uint256 i;\\n            i < _proposals[_proposalId].guardiansApproved.length;\\n            i++\\n        ) {\\n            if (_proposals[_proposalId].guardiansApproved[i] == msg.sender) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function _checkQuorumReached(\\n        uint256 _proposalId\\n    ) internal view returns (bool) {\\n        return ((_proposals[_proposalId].approvalCount * MULTIPLY_FACTOR) /\\n            guardianCount >=\\n            SIXTY_PERCENT);\\n    }\\n\\n    function _resolvedProposal() internal view returns (bool) {\\n        NewOwnerProposal storage prop = _proposals[proposalId];\\n        return prop.resolved;\\n    }\\n}\\n\",\"keccak256\":\"0xf4cdc1d7ab342177637b2aca0420219fd55e89da8764e4b1bf0b308ef82d0fb8\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/core/AccountBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title reference implementation of the minimal modular smart account with Hook Extension\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\ncontract AccountBase {\\n    error AccountAccessUnauthorized();\\n    /////////////////////////////////////////////////////\\n    // Access Control\\n    ////////////////////////////////////////////////////\\n\\n    modifier onlyEntryPointOrSelf() virtual {\\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEntryPoint() virtual {\\n        if (msg.sender != entryPoint()) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    function entryPoint() public view virtual returns (address) {\\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\\n    }\\n\\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\\n    /// Subclass MAY override this modifier for better funds management.\\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\\n    /// it will not be required to send again)\\n    ///\\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if missingAccountFunds {\\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\\n                pop(\\n                    call(\\n                        gas(),\\n                        caller(),\\n                        missingAccountFunds,\\n                        codesize(),\\n                        0x00,\\n                        codesize(),\\n                        0x00\\n                    )\\n                )\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x91aa799484224ba03f0293884be9742151d804abda4fd1bfe957a0de4ec2e4cf\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/core/ExecutionHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * @title Execution\\n * @dev This contract executes calls in the context of this contract.\\n * @author zeroknots.eth | rhinestone.wtf\\n * shoutout to solady (vectorized, ross) for this code\\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\\n */\\ncontract ExecutionHelper {\\n    error ExecutionFailed();\\n\\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\\n\\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function _tryExecute(Execution[] calldata executions)\\n        internal\\n        returns (bytes[] memory result)\\n    {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            bool success;\\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\\n        }\\n    }\\n\\n    function _execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    function _tryExecute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account.\\n    function _executeDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\\n    function _tryExecuteDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            success :=\\n                delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n}\",\"keccak256\":\"0x92eb764a6eba3a60c6b0891ccdff100ffffd4168fa7563b55860d5de3c9b4caa\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/core/HookManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./ModuleManager.sol\\\";\\nimport \\\"../interfaces/IERC7579Account.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n/**\\n * @title reference implementation of HookManager\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\n\\nabstract contract HookManager {\\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\\n    struct HookManagerStorage {\\n        IHook _hook;\\n    }\\n\\n    // keccak256(\\\"hookmanager.storage.msa\\\");\\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\\n        0x36e05829dd1b9a4411d96a3549582172d7f071c1c0db5c573fcf94eb28431608;\\n\\n    error HookPostCheckFailed();\\n    error HookAlreadyInstalled(address currentHook);\\n\\n    modifier withHook() {\\n        address hook = _getHook();\\n        if (hook == address(0)) {\\n            _;\\n        } else {\\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.data);\\n            _;\\n            if (!IHook(hook).postCheck(hookData)) revert HookPostCheckFailed();\\n        }\\n    }\\n\\n    function _setHook(address hook) internal virtual {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            sstore(slot, hook)\\n        }\\n    }\\n\\n    function _installHook(address hook, bytes calldata data) internal virtual {\\n        address currentHook = _getHook();\\n        if (currentHook != address(0)) {\\n            revert HookAlreadyInstalled(currentHook);\\n        }\\n        _setHook(hook);\\n        IHook(hook).onInstall(data);\\n    }\\n\\n    function _uninstallHook(\\n        address hook,\\n        bytes calldata data\\n    ) internal virtual {\\n        _setHook(address(0));\\n        IHook(hook).onUninstall(data);\\n    }\\n\\n    function _getHook() internal view returns (address _hook) {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            _hook := sload(slot)\\n        }\\n    }\\n\\n    function _isHookInstalled(address module) internal view returns (bool) {\\n        return _getHook() == module;\\n    }\\n\\n    function getActiveHook() external view returns (address hook) {\\n        return _getHook();\\n    }\\n}\\n\",\"keccak256\":\"0xf928c40e0ac91b9604ff3ed2d710d11882438c50ef5bde133010e8c5f4b0af5c\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/core/ModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {SentinelListLib, SENTINEL} from \\\"../libs/SentinelList.sol\\\";\\nimport {CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC} from \\\"../libs/ModeLib.sol\\\";\\nimport {AccountBase} from \\\"./AccountBase.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\nimport \\\"forge-std/interfaces/IERC165.sol\\\";\\nimport \\\"./Receiver.sol\\\";\\nimport {ArrayLib} from \\\"../../libraries/ArrayLib.sol\\\";\\n\\n/**\\n * @title ModuleManager\\n * @author zeroknots.eth | rhinestone.wtf\\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\\n * @dev it uses SentinelList to manage the linked list of modules\\n * NOTE: the linked list is just an example. accounts may implement this differently\\n */\\nabstract contract ModuleManager is AccountBase, Receiver {\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n\\n    error InvalidModule(address module);\\n    error NoFallbackHandler(bytes4 selector);\\n    error CannotRemoveLastValidator();\\n    error FallbackInvalidCallType();\\n    error InvalidFallbackCaller(address caller);\\n\\n    // keccak256(\\\"modulemanager.storage.msa\\\");\\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\\n        0xf88ce1fdb7fb1cbd3282e49729100fa3f2d6ee9f797961fe4fb1871cea89ea02;\\n\\n    struct FallbackHandler {\\n        address handler;\\n        CallType calltype;\\n        address[] allowedCallers;\\n    }\\n\\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\\n    struct ModuleManagerStorage {\\n        // linked list of validators. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $validators;\\n        // linked list of executors. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $executors;\\n        // single fallback handler for all fallbacks\\n        // account vendors may implement this differently. This is just a reference implementation\\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\\n    }\\n\\n    function $moduleManager()\\n        internal\\n        pure\\n        virtual\\n        returns (ModuleManagerStorage storage $ims)\\n    {\\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            $ims.slot := position\\n        }\\n    }\\n\\n    modifier onlyExecutorModule() {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\\n            .$executors;\\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyValidatorModule(address validator) {\\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\\n            .$validators;\\n        if (!$validators.contains(validator)) revert InvalidModule(validator);\\n        _;\\n    }\\n\\n    function _initModuleManager() internal virtual {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        $ims.$executors.init();\\n        $ims.$validators.init();\\n    }\\n\\n    function isAlreadyInitialized() internal view virtual returns (bool) {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        return $ims.$validators.alreadyInitialized();\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Validators\\n    ////////////////////////////////////////////////////\\n    function _installValidator(\\n        address validator,\\n        bytes calldata data\\n    ) internal virtual {\\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\\n            .$validators;\\n        $validators.push(validator);\\n        IValidator(validator).onInstall(data);\\n    }\\n\\n    function _uninstallValidator(\\n        address validator,\\n        bytes calldata data\\n    ) internal {\\n        // TODO: check if its the last validator. this might brick the account\\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\\n            .$validators;\\n        (address prev, bytes memory disableModuleData) = abi.decode(\\n            data,\\n            (address, bytes)\\n        );\\n        $validators.pop(prev, validator);\\n        IValidator(validator).onUninstall(disableModuleData);\\n    }\\n\\n    function _isValidatorInstalled(\\n        address validator\\n    ) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\\n            .$validators;\\n        return $validators.contains(validator);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getValidatorPaginated(\\n        address cursor,\\n        uint256 size\\n    ) external view virtual returns (address[] memory array, address next) {\\n        SentinelListLib.SentinelList storage $validators = $moduleManager()\\n            .$validators;\\n        return $validators.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Executors\\n    ////////////////////////////////////////////////////\\n\\n    function _installExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\\n            .$executors;\\n        $executors.push(executor);\\n        IExecutor(executor).onInstall(data);\\n    }\\n\\n    function _uninstallExecutor(\\n        address executor,\\n        bytes calldata data\\n    ) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\\n            .$executors;\\n        (address prev, bytes memory disableModuleData) = abi.decode(\\n            data,\\n            (address, bytes)\\n        );\\n        $executors.pop(prev, executor);\\n        IExecutor(executor).onUninstall(disableModuleData);\\n    }\\n\\n    function _isExecutorInstalled(\\n        address executor\\n    ) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\\n            .$executors;\\n        return $executors.contains(executor);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getExecutorsPaginated(\\n        address cursor,\\n        uint256 size\\n    ) external view virtual returns (address[] memory array, address next) {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager()\\n            .$executors;\\n        return $executors.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Fallback\\n    ////////////////////////////////////////////////////\\n\\n    function _installFallbackHandler(\\n        address handler,\\n        bytes calldata params\\n    ) internal virtual {\\n        bytes memory _params = params;\\n        bytes4 selector;\\n        CallType calltype;\\n        address[] memory allowedCallers;\\n        bytes memory initData;\\n        assembly {\\n            let configPtr := add(params.offset, 0x20)\\n            let configLen := calldataload(params.offset)\\n\\n            selector := calldataload(params.offset)\\n            calltype := calldataload(configPtr)\\n\\n            let allowedCallersLen := calldataload(add(configPtr, 0x20))\\n\\n            allowedCallers := mload(0x40)\\n            mstore(\\n                0x40,\\n                add(\\n                    allowedCallers,\\n                    and(add(mul(allowedCallersLen, 0x20), 0x1f), not(0x1f))\\n                )\\n            )\\n\\n            for {\\n                let i := 0\\n            } lt(i, allowedCallersLen) {\\n                i := add(i, 1)\\n            } {\\n                mstore(\\n                    add(allowedCallers, mul(i, 0x20)),\\n                    calldataload(add(configPtr, add(0x60, mul(i, 0x20))))\\n                )\\n            }\\n\\n            let initDataPos := calldataload(add(configPtr, 0x40))\\n            let initDataLen := calldataload(\\n                sub(add(configPtr, initDataPos), 0x20)\\n            )\\n            let initDataPtr := 0x60\\n            mstore(initDataPtr, initDataLen)\\n            calldatacopy(\\n                add(initDataPtr, 0x20),\\n                add(configPtr, initDataPos),\\n                initDataLen\\n            )\\n            initData := initDataPtr\\n        }\\n\\n        if (calltype == CALLTYPE_DELEGATECALL) revert FallbackInvalidCallType();\\n\\n        if (_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector already used\\\");\\n        }\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(\\n            handler,\\n            calltype,\\n            allowedCallers\\n        );\\n        IFallback(handler).onInstall(initData);\\n    }\\n\\n    function _uninstallFallbackHandler(\\n        address handler,\\n        bytes calldata deInitData\\n    ) internal virtual {\\n        bytes4 selector = bytes4(deInitData[0:4]);\\n        bytes memory _deInitData = deInitData[4:];\\n\\n        if (!_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector not used\\\");\\n        }\\n\\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[\\n            selector\\n        ];\\n\\n        if (activeFallback.handler != handler) {\\n            revert(\\\"Function selector not used by this handler\\\");\\n        }\\n\\n        CallType callType = activeFallback.calltype;\\n\\n        if (callType == CALLTYPE_DELEGATECALL) revert FallbackInvalidCallType();\\n        address[] memory allowedCallers = new address[](0);\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(\\n            address(0),\\n            CallType.wrap(0x00),\\n            allowedCallers\\n        );\\n\\n        IFallback(handler).onUninstall(_deInitData);\\n    }\\n\\n    function _isFallbackHandlerInstalled(\\n        bytes4 functionSig\\n    ) internal view virtual returns (bool) {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[\\n            functionSig\\n        ];\\n        return $fallback.handler != address(0);\\n    }\\n\\n    function _isFallbackHandlerInstalled(\\n        bytes4 functionSig,\\n        address _handler\\n    ) internal view virtual returns (bool) {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[\\n            functionSig\\n        ];\\n        return $fallback.handler == _handler;\\n    }\\n\\n    function getActiveFallbackHandler(\\n        bytes4 functionSig\\n    ) external view virtual returns (FallbackHandler memory) {\\n        return $moduleManager().$fallbacks[functionSig];\\n    }\\n\\n    // validates that the caller is allowed and reverts if not.\\n\\n    function _validateCaller(bytes4 sig) private view {\\n        address[] memory allowed = $moduleManager()\\n            .$fallbacks[sig]\\n            .allowedCallers;\\n        if (ArrayLib._contains(allowed, msg.sender) == false) {\\n            revert InvalidFallbackCaller(msg.sender);\\n        }\\n    }\\n\\n    // FALLBACK\\n    // calling _validateCaller()\\n\\n    fallback() external payable override(Receiver) {\\n        _validateCaller(msg.sig);\\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[\\n            msg.sig\\n        ];\\n        address handler = $fallbackHandler.handler;\\n        CallType calltype = $fallbackHandler.calltype;\\n\\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\\n\\n        if (calltype == CALLTYPE_STATIC) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success := staticcall(\\n                    gas(),\\n                    handler,\\n                    calldataPtr,\\n                    add(calldatasize(), 20),\\n                    0,\\n                    0\\n                )\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) {\\n                    revert(returnDataPtr, returndatasize())\\n                }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n        if (calltype == CALLTYPE_SINGLE) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success := call(\\n                    gas(),\\n                    handler,\\n                    0,\\n                    calldataPtr,\\n                    add(calldatasize(), 20),\\n                    0,\\n                    0\\n                )\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) {\\n                    revert(returnDataPtr, returndatasize())\\n                }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x34980edcd49f6c00978306077fe18171d6eda47a120d7d6071511e782efab33e\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/core/Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title Receiver\\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\\n * @author Modified from Solady\\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\\n */\\nabstract contract Receiver {\\n    /// @dev For receiving ETH.\\n    receive() external payable virtual {}\\n\\n    /// @dev Fallback function with the `receiverFallback` modifier.\\n    fallback() external payable virtual {}\\n}\\n\",\"keccak256\":\"0xf5ce3193d2ccdd09a14767cb39c775940de4bf99863a63fdb0a99c294a06ee88\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../libs/ModeLib.sol\\\";\\nimport {PackedUserOperation} from \\\"../../../../account-abstraction/contracts/interfaces/IAccount.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579Account {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *      The implementation of the function is OPTIONAL\\n     *\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function executeUserOp(PackedUserOperation calldata userOp) external payable;\\n\\n    /**\\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * this validation function should decode / sload the validator module to validate the userOp\\n     * and call it.\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        returns (uint256 validSignature);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\",\"keccak256\":\"0xb8d6b68dd9ebad9367cb3c2829033692b53b708301978bc2e3c6f9caaf503c8f\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IERC7579Module.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {PackedUserOperation} from \\\"../../../../account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\n\\nuint256 constant VALIDATION_SUCCESS = 0;\\nuint256 constant VALIDATION_FAILED = 1;\\n\\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\\nuint256 constant MODULE_TYPE_FALLBACK = 3;\\nuint256 constant MODULE_TYPE_HOOK = 4;\\n\\ninterface IModule {\\n    error AlreadyInitialized(address smartAccount);\\n    error NotInitialized(address smartAccount);\\n\\n    /**\\n     * @dev This function is called by the smart account during installation of the module\\n     * @param data arbitrary data that may be required on the module during `onInstall`\\n     * initialization\\n     *\\n     * MUST revert on error (i.e. if module is already enabled)\\n     */\\n    function onInstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev This function is called by the smart account during uninstallation of the module\\n     * @param data arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization\\n     *\\n     * MUST revert on error\\n     */\\n    function onUninstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns boolean value if module is a certain type\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *\\n     * MUST return true if the module is of the given type and false otherwise\\n     */\\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns if the module was already initialized for a provided smartaccount\\n     */\\n    function isInitialized(address smartAccount) external view returns (bool);\\n}\\n\\ninterface IValidator is IModule {\\n    error InvalidTargetAddress(address target);\\n\\n    /**\\n     * @dev Validates a transaction on behalf of the account.\\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\\n     * The MSA MUST clean up the userOp before sending it to the validator.\\n     * @param userOpHash The hash of the user operation to be validated\\n     * @return return value according to ERC-4337\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * Validator can be used for ERC-1271 validation\\n     */\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\\ninterface IExecutor is IModule { }\\n\\ninterface IHook is IModule {\\n    function preCheck(\\n        address msgSender,\\n        bytes calldata msgData\\n    )\\n        external\\n        returns (bytes memory hookData);\\n    function postCheck(bytes calldata hookData) external returns (bool success);\\n}\\n\\ninterface IFallback is IModule { }\",\"keccak256\":\"0xb70280ab96b9dcfed3c559a3a1ed64850fc2171374e5809d2d2887c4956c8379\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/interfaces/IMSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IERC7579Account} from \\\"./IERC7579Account.sol\\\";\\n\\nimport {CallType, ExecType, ModeCode} from \\\"../libs/ModeLib.sol\\\";\\n\\ninterface IMSA is IERC7579Account {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleType);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) external payable;\\n}\\n\",\"keccak256\":\"0xe8fdf22aec84d6d189646659ef3a659f81e42a0885c962827269ff4ce4eeba84\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/libs/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {Execution} from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(\\n        bytes calldata callData\\n    ) internal pure returns (Execution[] calldata executionBatch) {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(\\n                callData.offset,\\n                calldataload(callData.offset)\\n            )\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(\\n        Execution[] memory executions\\n    ) internal pure returns (bytes memory callData) {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(\\n        bytes calldata executionCalldata\\n    )\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    ) internal pure returns (bytes memory userOpCalldata) {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0xad2974b9073a9dd7eb9c6fc33c9becce272d270d7c14b4438a92221c0e1f0126\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/libs/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\",\"keccak256\":\"0x9c0886362e13274bb5e255ff391b13290461ce02b58d9dff9ae55b5bd01fcba3\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/erc7579-ref-impl/libs/SentinelList.sol\":{\"content\":\"// https://github.com/zeroknots/sentinellist/\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\naddress constant SENTINEL = address(0x1);\\naddress constant ZERO_ADDRESS = address(0x0);\\n\\nlibrary SentinelListLib {\\n    struct SentinelList {\\n        mapping(address => address) entries;\\n    }\\n\\n    error LinkedList_AlreadyInitialized();\\n    error LinkedList_InvalidPage();\\n    error LinkedList_InvalidEntry(address entry);\\n    error LinkedList_EntryAlreadyInList(address entry);\\n\\n    function init(SentinelList storage self) internal {\\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\\n        self.entries[SENTINEL] = SENTINEL;\\n    }\\n\\n    function alreadyInitialized(\\n        SentinelList storage self\\n    ) internal view returns (bool) {\\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\\n    }\\n\\n    function getNext(\\n        SentinelList storage self,\\n        address entry\\n    ) internal view returns (address) {\\n        if (entry == ZERO_ADDRESS) {\\n            revert LinkedList_InvalidEntry(entry);\\n        }\\n        return self.entries[entry];\\n    }\\n\\n    function push(SentinelList storage self, address newEntry) internal {\\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(newEntry);\\n        }\\n        if (self.entries[newEntry] != ZERO_ADDRESS)\\n            revert LinkedList_EntryAlreadyInList(newEntry);\\n        self.entries[newEntry] = self.entries[SENTINEL];\\n        self.entries[SENTINEL] = newEntry;\\n    }\\n\\n    function pop(\\n        SentinelList storage self,\\n        address prevEntry,\\n        address popEntry\\n    ) internal {\\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(prevEntry);\\n        }\\n        if (self.entries[prevEntry] != popEntry)\\n            revert LinkedList_InvalidEntry(popEntry);\\n        self.entries[prevEntry] = self.entries[popEntry];\\n        self.entries[popEntry] = ZERO_ADDRESS;\\n    }\\n\\n    function contains(\\n        SentinelList storage self,\\n        address entry\\n    ) internal view returns (bool) {\\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\\n    }\\n\\n    function getEntriesPaginated(\\n        SentinelList storage self,\\n        address start,\\n        uint256 pageSize\\n    ) internal view returns (address[] memory array, address next) {\\n        if (start != SENTINEL && contains(self, start))\\n            revert LinkedList_InvalidEntry(start);\\n        if (pageSize == 0) revert LinkedList_InvalidPage();\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 entryCount = 0;\\n        next = self.entries[start];\\n        while (\\n            next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize\\n        ) {\\n            array[entryCount] = next;\\n            next = self.entries[next];\\n            entryCount++;\\n        }\\n\\n        /**\\n         * Because of the argument validation, we can assume that the loop will always iterate over the valid entry list values\\n         *       and the `next` variable will either be an enabled entry or a sentinel address (signalling the end).\\n         *\\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to the last element of the entry array\\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the start of the next page is neither\\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a start.\\n         */\\n        if (next != SENTINEL) {\\n            next = array[entryCount - 1];\\n        }\\n        // Set correct size of returned array\\n        // solhint-disable-next-line no-inline-assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(array, entryCount)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb80e28790644ad9d8080197483988cc9eed7a9c9e1c3583139d5f58b8fc28e74\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/interfaces/IAccessController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IAccessController {\\n    /// Structs\\n    struct NewOwnerProposal {\\n        address newOwnerProposed;\\n        bool resolved;\\n        address[] guardiansApproved;\\n        uint256 approvalCount;\\n        uint256 proposedAt;\\n    }\\n\\n    /// Events\\n    event OwnerAdded(address account, address newOwner);\\n    event OwnerRemoved(address account, address removedOwner);\\n    event GuardianAdded(address account, address newGuardian);\\n    event GuardianRemoved(address account, address removedGuardian);\\n    event ProposalSubmitted(\\n        address account,\\n        uint256 proposalId,\\n        address newOwnerProposed,\\n        address proposer\\n    );\\n    event QuorumNotReached(\\n        address account,\\n        uint256 proposalId,\\n        address newOwnerProposed,\\n        uint256 approvalCount\\n    );\\n    event ProposalDiscarded(\\n        address account,\\n        uint256 proposalId,\\n        address discardedBy\\n    );\\n\\n    /// External\\n    function addOwner(address _newOwner) external;\\n\\n    function removeOwner(address _owner) external;\\n\\n    function addGuardian(address _newGuardian) external;\\n\\n    function removeGuardian(address _guardian) external;\\n\\n    function changeProposalTimelock(uint256 _newTimelock) external;\\n\\n    function discardCurrentProposal() external;\\n\\n    function guardianPropose(address _newOwner) external;\\n\\n    function guardianCosign() external;\\n\\n    /// Views\\n    function isOwner(address _address) external view returns (bool);\\n\\n    function isGuardian(address _address) external view returns (bool);\\n\\n    function getProposal(\\n        uint256 _proposalId\\n    )\\n        external\\n        view\\n        returns (\\n            address ownerProposed_,\\n            uint256 approvalCount_,\\n            address[] memory guardiansApproved_,\\n            bool resolved_,\\n            uint256 proposedAt_\\n        );\\n}\\n\",\"keccak256\":\"0x7b145487fed51865b8f8fd3bd6ff799360146d8dbb9b7651e5d8e7bbb6eed930\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/interfaces/IModularEtherspotWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IMSA} from \\\"../erc7579-ref-impl/interfaces/IMSA.sol\\\";\\nimport {IAccessController} from \\\"./IAccessController.sol\\\";\\n\\ninterface IModularEtherspotWallet is IMSA, IAccessController\\n{\\n  error OnlyProxy();\\n}\\n\",\"keccak256\":\"0x1af5ab78210983978c8312d129ed3f01bb12e30b4494315e89067922fdcffd75\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/libraries/ArrayLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nlibrary ArrayLib {\\n    function _contains(\\n        address[] memory A,\\n        address a\\n    ) internal pure returns (bool) {\\n        (, bool isIn) = _indexOf(A, a);\\n        return isIn;\\n    }\\n\\n    function _indexOf(\\n        address[] memory A,\\n        address a\\n    ) internal pure returns (uint256, bool) {\\n        uint256 length = A.length;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (A[i] == a) {\\n                return (i, true);\\n            }\\n        }\\n        return (0, false);\\n    }\\n\\n    function _removeElement(\\n        address[] storage _data,\\n        address _element\\n    ) internal {\\n        uint256 length = _data.length;\\n        // remove item from array and resize array\\n        for (uint256 ii = 0; ii < length; ii++) {\\n            if (_data[ii] == _element) {\\n                if (length > 1) {\\n                    _data[ii] = _data[length - 1];\\n                }\\n                _data.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _removeElement(\\n        address[] memory _data,\\n        address _element\\n    ) internal pure returns (address[] memory) {\\n        address[] memory newData = new address[](_data.length - 1);\\n        uint256 j;\\n        for (uint256 i; i < _data.length; i++) {\\n            if (_data[i] != _element) {\\n                newData[j] = _data[i];\\n                j++;\\n            }\\n        }\\n        return newData;\\n    }\\n}\\n\",\"keccak256\":\"0x6179c61cbc4fc0c811dce30e94e4ecf647c472c57ad10dc8cefb7b9cbde458d9\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/libraries/ErrorsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nlibrary ErrorsLib {\\n    /// AccessController\\n    error OnlyOwnerOrSelf();\\n    error OnlyGuardian();\\n    error OnlyOwnerOrGuardianOrSelf();\\n\\n    error AddingInvalidOwner();\\n    error RemovingInvalidOwner();\\n    error AddingInvalidGuardian();\\n    error RemovingInvalidGuardian();\\n\\n    error WalletNeedsOwner();\\n    error NotEnoughGuardians();\\n\\n    error ProposalResolved();\\n    error ProposalUnresolved();\\n    error AlreadySignedProposal();\\n\\n    error ProposalTimelocked();\\n    error InvalidProposal();\\n\\n    // EtherspotWallet7579 Errors\\n}\\n\",\"keccak256\":\"0x9efef01177a836a407e12ba61ef9276901c31c640e1d3a6aecdca1585715b268\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/modules/validators/MultipleOwnerECDSAValidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"../../erc7579-ref-impl/interfaces/IERC7579Account.sol\\\";\\nimport \\\"../../erc7579-ref-impl/interfaces/IERC7579Module.sol\\\";\\nimport \\\"../../erc7579-ref-impl/libs/ModeLib.sol\\\";\\nimport \\\"../../erc7579-ref-impl/libs/ExecutionLib.sol\\\";\\nimport {ModularEtherspotWallet} from \\\"../../wallet/ModularEtherspotWallet.sol\\\";\\nimport {ECDSA} from \\\"solady/src/utils/ECDSA.sol\\\";\\nimport {EIP712} from \\\"solady/src/utils/EIP712.sol\\\";\\n\\ncontract MultipleOwnerECDSAValidator is EIP712, IValidator {\\n    using ExecutionLib for bytes;\\n    using ECDSA for bytes32;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    string constant NAME = \\\"MultipleOwnerECDSAValidator\\\";\\n    string constant VERSION = \\\"1.0.0\\\";\\n\\n    error InvalidExec();\\n\\n    mapping(address => bool) internal _initialized;\\n\\n    function onInstall(bytes calldata data) external override {\\n        if (isInitialized(msg.sender)) revert AlreadyInitialized(msg.sender);\\n        _initialized[msg.sender] = true;\\n    }\\n\\n    function onUninstall(bytes calldata data) external override {\\n        if (!isInitialized(msg.sender)) revert NotInitialized(msg.sender);\\n        _initialized[msg.sender] = false;\\n    }\\n\\n    function isInitialized(\\n        address smartAccount\\n    ) public view override returns (bool) {\\n        return _initialized[smartAccount];\\n    }\\n\\n    function isModuleType(\\n        uint256 typeID\\n    ) external pure override returns (bool) {\\n        return typeID == MODULE_TYPE_VALIDATOR;\\n    }\\n\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    ) external override returns (uint256) {\\n        bytes32 domainSeparator = _domainSeparator();\\n        bytes32 signedMessageHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, userOpHash)\\n        );\\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(signedMessageHash);\\n        address signer = ECDSA.recover(ethHash, userOp.signature);\\n\\n        // bytes32 hash = userOpHash.toEthSignedMessageHash();\\n        // address signer = hash.recover(userOp.signature);\\n        if (\\n            signer == address(0) ||\\n            !ModularEtherspotWallet(payable(msg.sender)).isOwner(signer)\\n        ) {\\n            return VALIDATION_FAILED;\\n        }\\n        // get the function selector that will be called by EntryPoint\\n        bytes4 execFunction = bytes4(userOp.callData[:4]);\\n\\n        // get the mode\\n        CallType callType = CallType.wrap(bytes1(userOp.callData[4]));\\n        bytes calldata executionCalldata = userOp.callData[36:];\\n        if (callType == CALLTYPE_BATCH) {\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            (\\n                address target,\\n                uint256 value,\\n                bytes calldata callData\\n            ) = executionCalldata.decodeSingle();\\n        }\\n    }\\n\\n    function isValidSignatureWithSender(\\n        address,\\n        bytes32 hash,\\n        bytes calldata data\\n    ) external view override returns (bytes4) {\\n        // Include the proxy address in the domain separator\\n        bytes32 domainSeparator = _domainSeparator();\\n        bytes32 signedMessageHash = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, hash)\\n        );\\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(signedMessageHash);\\n        address owner = ECDSA.recover(ethHash, data);\\n        if (ModularEtherspotWallet(payable(msg.sender)).isOwner(owner)) {\\n            return 0x1626ba7e;\\n        }\\n        return 0xffffffff;\\n    }\\n\\n    function _domainSeparator() internal view override returns (bytes32) {\\n        (string memory _name, string memory _version) = _domainNameAndVersion();\\n        bytes32 nameHash = keccak256(bytes(_name));\\n        bytes32 versionHash = keccak256(bytes(_version));\\n        // Use the proxy address for the EIP-712 domain separator.\\n        address proxyAddress = address(this);\\n\\n        // Construct the domain separator with name, version, chainId, and proxy address.\\n        bytes32 typeHash = EIP712_DOMAIN_TYPEHASH;\\n        return\\n            keccak256(\\n                abi.encode(\\n                    typeHash,\\n                    nameHash,\\n                    versionHash,\\n                    block.chainid,\\n                    proxyAddress\\n                )\\n            );\\n    }\\n\\n    function _domainNameAndVersion()\\n        internal\\n        pure\\n        override\\n        returns (string memory, string memory)\\n    {\\n        return (NAME, VERSION);\\n    }\\n}\\n\",\"keccak256\":\"0x9462518ebd769ac8d8a45370b740a3473a7cf60b22300abf441c3947a3f60437\",\"license\":\"MIT\"},\"src/modular-etherspot-wallet/wallet/ModularEtherspotWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"../erc7579-ref-impl/libs/ModeLib.sol\\\";\\nimport {ExecutionLib} from \\\"../erc7579-ref-impl/libs/ExecutionLib.sol\\\";\\nimport {ExecutionHelper} from \\\"../erc7579-ref-impl/core/ExecutionHelper.sol\\\";\\nimport {PackedUserOperation} from \\\"../../../account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\nimport \\\"../erc7579-ref-impl/interfaces/IERC7579Module.sol\\\";\\nimport {IModularEtherspotWallet} from \\\"../interfaces/IModularEtherspotWallet.sol\\\";\\nimport {ModuleManager} from \\\"../erc7579-ref-impl/core/ModuleManager.sol\\\";\\nimport {HookManager} from \\\"../erc7579-ref-impl/core/HookManager.sol\\\";\\nimport {AccessController} from \\\"../access/AccessController.sol\\\";\\n\\ncontract ModularEtherspotWallet is\\n    AccessController,\\n    IModularEtherspotWallet,\\n    ExecutionHelper,\\n    ModuleManager,\\n    HookManager\\n{\\n    using ExecutionLib for bytes;\\n    using ModeLib for ModeCode;\\n    address public immutable implementation = address(this);\\n\\n    /**\\n     * @dev modifier to restrict access to calling on implementation\\n     */\\n    modifier onlyProxy() {\\n        if (address(this) == implementation) revert OnlyProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev see {IERC7579Account}.\\n     * @dev this function is only callable by the entry point or the account itself\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function execute(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    ) external payable onlyEntryPointOrSelf withHook {\\n        (CallType callType, ExecType execType, , ) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (\\n                address target,\\n                uint256 value,\\n                bytes calldata callData\\n            ) = executionCalldata.decodeSingle();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT)\\n                _execute(target, value, callData);\\n                // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY)\\n                _tryExecute(target, value, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(\\n                uint160(bytes20(executionCalldata[0:20]))\\n            );\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT)\\n                _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY)\\n                _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @dev see {IERC7579Account}.\\n     * @dev this function is only callable by an installed executor module\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyExecutorModule\\n        withHook\\n        returns (\\n            bytes[] memory returnData // TODO returnData is not used\\n        )\\n    {\\n        (CallType callType, ExecType execType, , ) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\\n            else if (execType == EXECTYPE_TRY)\\n                returnData = _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (\\n                address target,\\n                uint256 value,\\n                bytes calldata callData\\n            ) = executionCalldata.decodeSingle();\\n            returnData = new bytes[](1);\\n            bool success;\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) {\\n                returnData[0] = _execute(target, value, callData);\\n            }\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) {\\n                (success, returnData[0]) = _tryExecute(target, value, callData);\\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\\n            } else {\\n                revert UnsupportedExecType(execType);\\n            }\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(\\n                uint160(bytes20(executionCalldata[0:20]))\\n            );\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT)\\n                _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY)\\n                _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     *  @dev see {IERC7579Account}.\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp\\n    ) external payable onlyEntryPointOrSelf {\\n        bytes calldata callData = userOp.callData[4:];\\n        (bool success, ) = address(this).delegatecall(callData);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    /**\\n     *  @dev see {IERC7579Account}.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    ) external payable onlyEntryPointOrSelf {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR)\\n            _installValidator(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR)\\n            _installExecutor(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            _installFallbackHandler(module, initData);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK)\\n            _installHook(module, initData);\\n        else revert UnsupportedModuleType(moduleTypeId);\\n        emit ModuleInstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     *  @dev see {IERC7579Account}.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    ) external payable onlyEntryPointOrSelf {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            _uninstallValidator(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            _uninstallExecutor(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            _uninstallFallbackHandler(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            _uninstallHook(module, deInitData);\\n        } else {\\n            revert UnsupportedModuleType(moduleTypeId);\\n        }\\n        emit ModuleUninstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @dev see {IERC7579Account}.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        virtual\\n        override\\n        onlyEntryPoint\\n        payPrefund(missingAccountFunds)\\n        returns (uint256 validSignature)\\n    {\\n        address validator;\\n        // @notice validator encoding in nonce is just an example!\\n        // @notice this is not part of the standard!\\n        // Account Vendors may choose any other way to implement validator selection\\n        uint256 nonce = userOp.nonce;\\n        assembly {\\n            validator := shr(96, nonce)\\n        }\\n\\n        // check if validator is enabled. If not terminate the validation phase.\\n        if (!_isValidatorInstalled(validator)) return VALIDATION_FAILED;\\n\\n        // bubble up the return value of the validator module\\n        validSignature = IValidator(validator).validateUserOp(\\n            userOp,\\n            userOpHash\\n        );\\n    }\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes calldata data\\n    ) external view virtual override returns (bytes4) {\\n        address validator = address(bytes20(data[0:20]));\\n        if (!_isValidatorInstalled(validator)) revert InvalidModule(validator);\\n        return\\n            IValidator(validator).isValidSignatureWithSender(\\n                msg.sender,\\n                hash,\\n                data[20:]\\n            );\\n    }\\n\\n    /**\\n     * @dev see {IERC7579Account}.\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    ) external view override returns (bool) {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            return _isValidatorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            return _isExecutorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            return\\n                _isFallbackHandlerInstalled(\\n                    abi.decode(additionalContext, (bytes4)),\\n                    module\\n                );\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            return _isHookInstalled(module);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     *  @dev see {IERC7579Account}.\\n     */\\n    function accountId()\\n        external\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        return \\\"etherspotwallet.modular.v1.0.0\\\";\\n    }\\n\\n    /**\\n     * @dev see {IERC7579Account}.\\n     */\\n    function supportsExecutionMode(\\n        ModeCode mode\\n    ) external view virtual override returns (bool isSupported) {\\n        (CallType callType, ExecType execType, , ) = mode.decode();\\n        if (callType == CALLTYPE_BATCH) isSupported = true;\\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\\n        else if (callType == CALLTYPE_DELEGATECALL)\\n            isSupported = true;\\n            // if callType is not single, batch or delegatecall return false\\n        else return false;\\n\\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\\n        else if (execType == EXECTYPE_TRY)\\n            isSupported = true;\\n            // if execType is not default or try, return false\\n        else return false;\\n    }\\n\\n    /**\\n     *  @dev see {IERC7579Account}.\\n     */\\n    function supportsModule(\\n        uint256 modulTypeId\\n    ) external view virtual override returns (bool) {\\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     *  @dev see {IERC7579Account}.\\n     */\\n    function initializeAccount(\\n        bytes calldata data\\n    ) public payable virtual onlyProxy {\\n        _initModuleManager();\\n        (address owner, address bootstrap, bytes memory bootstrapCall) = abi\\n            .decode(data, (address, address, bytes));\\n        _addOwner(owner);\\n        (bool success, ) = bootstrap.delegatecall(bootstrapCall);\\n        if (!success) revert AccountInitializationFailed();\\n    }\\n}\\n\",\"keccak256\":\"0x102592be7d447e1efd3073240421e32eb81c2175d427d8c557875f7e30367c60\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61012060405234801561001157600080fd5b50306080524660a052606080610073604080518082018252601b81527f4d756c7469706c654f776e6572454344534156616c696461746f720000000000602080830191909152825180840190935260058352640312e302e360dc1b9083015291565b815160209283012081519183019190912060c082905260e0819052604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152938401929092529082015246606082015230608082015260a0902061010052506100dc9050565b60805160a05160c05160e05161010051610b2e6101116000396000505060005050600050506000505060005050610b2e6000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063970032031161005b57806397003203146100ce578063d60b347f146100ef578063ecd059611461012b578063f551e2ee1461013f57600080fd5b80636d61fe701461008257806384b0196e146100975780638a91b0e3146100bb575b600080fd5b6100956100903660046107b1565b61016b565b005b61009f6101c1565b6040516100b29796959493929190610839565b60405180910390f35b6100956100c93660046107b1565b6101e8565b6100e16100dc3660046108d2565b610235565b6040519081526020016100b2565b61011b6100fd366004610939565b6001600160a01b031660009081526020819052604090205460ff1690565b60405190151581526020016100b2565b61011b61013936600461095b565b60011490565b61015261014d366004610974565b610457565b6040516001600160e01b031990911681526020016100b2565b3360009081526020819052604090205460ff16156101a3576040516393360fbf60e01b81523360048201526024015b60405180910390fd5b5050336000908152602081905260409020805460ff19166001179055565b600f60f81b60608060008080836101d66105b0565b97989097965046955030945091925090565b3360009081526020819052604090205460ff1661021a5760405163f91bd6f160e01b815233600482015260240161019a565b5050336000908152602081905260409020805460ff19169055565b600080610240610603565b60405161190160f01b6020820152602281018290526042810185905290915060009060620160405160208183030381529060405280519060200120905060006102ae826020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b905060006102fe826102c46101008a018a6109ce565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061068692505050565b90506001600160a01b038116158061037b57506040516317aa5fb760e11b81526001600160a01b03821660048201523390632f54bf6e90602401602060405180830381865afa158015610355573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103799190610a15565b155b1561038d576001945050505050610451565b600061039c60608901896109ce565b6103ab91600491600091610a37565b6103b491610a61565b905060006103c560608a018a6109ce565b60048181106103d6576103d6610a91565b909101356001600160f81b031916915036905060006103f860608c018c6109ce565b610406916024908290610a37565b9092509050600160f81b6001600160f81b0319841614610448576001600160f81b031983166104485760008036600061043f8686610717565b50505050505050505b50505050505050505b92915050565b600080610462610603565b60405161190160f01b6020820152602281018290526042810187905290915060009060620160405160208183030381529060405280519060200120905060006104d0826020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b905060006105148288888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061068692505050565b6040516317aa5fb760e11b81526001600160a01b03821660048201529091503390632f54bf6e90602401602060405180830381865afa15801561055b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061057f9190610a15565b156105985750630b135d3f60e11b93506105a892505050565b506001600160e01b031993505050505b949350505050565b604080518082018252601b81527f4d756c7469706c654f776e6572454344534156616c696461746f720000000000602080830191909152825180840190935260058352640312e302e360dc1b9083015291565b60008060006106106105b0565b8151602092830120815191830191909120604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f818601528082019390935260608301919091524660808301523060a0808401919091528151808403909101815260c0909201905280519101209392505050565b60405160019083600052602083015160405260408351036106c257604083015160ff81901c601b016020526001600160ff1b03166060526106e8565b60418351036106e357606083015160001a60205260408301516060526106e8565b600091505b6020600160806000855afa5191503d61070957638baa579f6000526004601cfd5b600060605260405292915050565b60008036816107296014828789610a37565b61073291610aa7565b60601c9350610745603460148789610a37565b61074e91610ada565b925061075d8560348189610a37565b949793965094505050565b60008083601f84011261077a57600080fd5b50813567ffffffffffffffff81111561079257600080fd5b6020830191508360208285010111156107aa57600080fd5b9250929050565b600080602083850312156107c457600080fd5b823567ffffffffffffffff8111156107db57600080fd5b6107e785828601610768565b90969095509350505050565b6000815180845260005b81811015610819576020818501810151868301820152016107fd565b506000602082860101526020601f19601f83011685010191505092915050565b60ff60f81b881681526000602060e0602084015261085a60e084018a6107f3565b838103604085015261086c818a6107f3565b606085018990526001600160a01b038816608086015260a0850187905284810360c08601528551808252602080880193509091019060005b818110156108c0578351835292840192918401916001016108a4565b50909c9b505050505050505050505050565b600080604083850312156108e557600080fd5b823567ffffffffffffffff8111156108fc57600080fd5b8301610120818603121561090f57600080fd5b946020939093013593505050565b80356001600160a01b038116811461093457600080fd5b919050565b60006020828403121561094b57600080fd5b6109548261091d565b9392505050565b60006020828403121561096d57600080fd5b5035919050565b6000806000806060858703121561098a57600080fd5b6109938561091d565b935060208501359250604085013567ffffffffffffffff8111156109b657600080fd5b6109c287828801610768565b95989497509550505050565b6000808335601e198436030181126109e557600080fd5b83018035915067ffffffffffffffff821115610a0057600080fd5b6020019150368190038213156107aa57600080fd5b600060208284031215610a2757600080fd5b8151801515811461095457600080fd5b60008085851115610a4757600080fd5b83861115610a5457600080fd5b5050820193919092039150565b6001600160e01b03198135818116916004851015610a895780818660040360031b1b83161692505b505092915050565b634e487b7160e01b600052603260045260246000fd5b6bffffffffffffffffffffffff198135818116916014851015610a895760149490940360031b84901b1690921692915050565b8035602083101561045157600019602084900360031b1b169291505056fea26469706673582212208acd74d6796b3ab1fa6a67022d34ee835de871fdb363293b4be7659ef92417b464736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061007d5760003560e01c8063970032031161005b57806397003203146100ce578063d60b347f146100ef578063ecd059611461012b578063f551e2ee1461013f57600080fd5b80636d61fe701461008257806384b0196e146100975780638a91b0e3146100bb575b600080fd5b6100956100903660046107b1565b61016b565b005b61009f6101c1565b6040516100b29796959493929190610839565b60405180910390f35b6100956100c93660046107b1565b6101e8565b6100e16100dc3660046108d2565b610235565b6040519081526020016100b2565b61011b6100fd366004610939565b6001600160a01b031660009081526020819052604090205460ff1690565b60405190151581526020016100b2565b61011b61013936600461095b565b60011490565b61015261014d366004610974565b610457565b6040516001600160e01b031990911681526020016100b2565b3360009081526020819052604090205460ff16156101a3576040516393360fbf60e01b81523360048201526024015b60405180910390fd5b5050336000908152602081905260409020805460ff19166001179055565b600f60f81b60608060008080836101d66105b0565b97989097965046955030945091925090565b3360009081526020819052604090205460ff1661021a5760405163f91bd6f160e01b815233600482015260240161019a565b5050336000908152602081905260409020805460ff19169055565b600080610240610603565b60405161190160f01b6020820152602281018290526042810185905290915060009060620160405160208183030381529060405280519060200120905060006102ae826020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b905060006102fe826102c46101008a018a6109ce565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061068692505050565b90506001600160a01b038116158061037b57506040516317aa5fb760e11b81526001600160a01b03821660048201523390632f54bf6e90602401602060405180830381865afa158015610355573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103799190610a15565b155b1561038d576001945050505050610451565b600061039c60608901896109ce565b6103ab91600491600091610a37565b6103b491610a61565b905060006103c560608a018a6109ce565b60048181106103d6576103d6610a91565b909101356001600160f81b031916915036905060006103f860608c018c6109ce565b610406916024908290610a37565b9092509050600160f81b6001600160f81b0319841614610448576001600160f81b031983166104485760008036600061043f8686610717565b50505050505050505b50505050505050505b92915050565b600080610462610603565b60405161190160f01b6020820152602281018290526042810187905290915060009060620160405160208183030381529060405280519060200120905060006104d0826020527b19457468657265756d205369676e6564204d6573736167653a0a3332600052603c60042090565b905060006105148288888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061068692505050565b6040516317aa5fb760e11b81526001600160a01b03821660048201529091503390632f54bf6e90602401602060405180830381865afa15801561055b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061057f9190610a15565b156105985750630b135d3f60e11b93506105a892505050565b506001600160e01b031993505050505b949350505050565b604080518082018252601b81527f4d756c7469706c654f776e6572454344534156616c696461746f720000000000602080830191909152825180840190935260058352640312e302e360dc1b9083015291565b60008060006106106105b0565b8151602092830120815191830191909120604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f818601528082019390935260608301919091524660808301523060a0808401919091528151808403909101815260c0909201905280519101209392505050565b60405160019083600052602083015160405260408351036106c257604083015160ff81901c601b016020526001600160ff1b03166060526106e8565b60418351036106e357606083015160001a60205260408301516060526106e8565b600091505b6020600160806000855afa5191503d61070957638baa579f6000526004601cfd5b600060605260405292915050565b60008036816107296014828789610a37565b61073291610aa7565b60601c9350610745603460148789610a37565b61074e91610ada565b925061075d8560348189610a37565b949793965094505050565b60008083601f84011261077a57600080fd5b50813567ffffffffffffffff81111561079257600080fd5b6020830191508360208285010111156107aa57600080fd5b9250929050565b600080602083850312156107c457600080fd5b823567ffffffffffffffff8111156107db57600080fd5b6107e785828601610768565b90969095509350505050565b6000815180845260005b81811015610819576020818501810151868301820152016107fd565b506000602082860101526020601f19601f83011685010191505092915050565b60ff60f81b881681526000602060e0602084015261085a60e084018a6107f3565b838103604085015261086c818a6107f3565b606085018990526001600160a01b038816608086015260a0850187905284810360c08601528551808252602080880193509091019060005b818110156108c0578351835292840192918401916001016108a4565b50909c9b505050505050505050505050565b600080604083850312156108e557600080fd5b823567ffffffffffffffff8111156108fc57600080fd5b8301610120818603121561090f57600080fd5b946020939093013593505050565b80356001600160a01b038116811461093457600080fd5b919050565b60006020828403121561094b57600080fd5b6109548261091d565b9392505050565b60006020828403121561096d57600080fd5b5035919050565b6000806000806060858703121561098a57600080fd5b6109938561091d565b935060208501359250604085013567ffffffffffffffff8111156109b657600080fd5b6109c287828801610768565b95989497509550505050565b6000808335601e198436030181126109e557600080fd5b83018035915067ffffffffffffffff821115610a0057600080fd5b6020019150368190038213156107aa57600080fd5b600060208284031215610a2757600080fd5b8151801515811461095457600080fd5b60008085851115610a4757600080fd5b83861115610a5457600080fd5b5050820193919092039150565b6001600160e01b03198135818116916004851015610a895780818660040360031b1b83161692505b505092915050565b634e487b7160e01b600052603260045260246000fd5b6bffffffffffffffffffffffff198135818116916014851015610a895760149490940360031b84901b1690921692915050565b8035602083101561045157600019602084900360031b1b169291505056fea26469706673582212208acd74d6796b3ab1fa6a67022d34ee835de871fdb363293b4be7659ef92417b464736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "eip712Domain()": {
        "details": "See: https://eips.ethereum.org/EIPS/eip-5267"
      },
      "isInitialized(address)": {
        "details": "Returns if the module was already initialized for a provided smartaccount"
      },
      "onInstall(bytes)": {
        "details": "This function is called by the smart account during installation of the module",
        "params": {
          "data": "arbitrary data that may be required on the module during `onInstall` initialization MUST revert on error (i.e. if module is already enabled)"
        }
      },
      "onUninstall(bytes)": {
        "details": "This function is called by the smart account during uninstallation of the module",
        "params": {
          "data": "arbitrary data that may be required on the module during `onUninstall` de-initialization MUST revert on error"
        }
      },
      "validateUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32)": {
        "details": "Validates a transaction on behalf of the account.         This function is intended to be called by the MSA during the ERC-4337 validaton phase         Note: solely relying on bytes32 hash and signature is not suffcient for some validation implementations (i.e. SessionKeys often need access to userOp.calldata)",
        "params": {
          "userOp": "The user operation to be validated. The userOp MUST NOT contain any metadata. The MSA MUST clean up the userOp before sending it to the validator.",
          "userOpHash": "The hash of the user operation to be validated"
        },
        "returns": {
          "_0": "return value according to ERC-4337"
        }
      }
    },
    "stateVariables": {
      "EIP712_DOMAIN_TYPEHASH": {
        "details": "`keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 62828,
        "contract": "src/modular-etherspot-wallet/modules/validators/MultipleOwnerECDSAValidator.sol:MultipleOwnerECDSAValidator",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}